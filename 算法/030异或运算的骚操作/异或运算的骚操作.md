![image-20251222220140833](%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C.assets/image-20251222220140833.png)

<br>

![image-20251222221338845](%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C.assets/image-20251222221338845.png)

<br>

# 1. 异或运算性质

对一些性质做简单的解释。

<br>

**异或运算就是无进位相加**

A = 01101110，B = 10011101

如果要算 A ^ B ，则计算方法如下：

A:	0 1 1 0 1 1 1 0

B:	1 0 0 1 1 1 0 1

​		1 1 1 1 0 0 11

低位第三位，两个1相加有进位，我们不要这个进位，只留下0。其他的也同理。

A ^ B =  (0110111) ^ (10011101) = 11110011

<br>

**整体异或和如果是×，整体中某个部分的异或和如果是y，那么剩下部分的异或和是 x ^ y**

假设有一个数组，其索引 0 ~ 17 上的元素异或和为 x，而索引 3、5、6、13上的元素异或和为 y。

那么剩下的元素异或和为 x ^ y。

也就是说，如果存在条件 a ^ b = c，则能得出 a = b ^ c，c = a ^ b。



# 2. 解释白球黑球问题

袋子中一共有 a 个白球， b 个黑球。每次从袋子要求拿出两个球。

如果拿出一个白球，一个黑球，就重新往袋子放入一个黑球。

我们将白球看作0，黑球看作1，拿到一白一黑的情况，也就是 0 ^ 1 = 1 ^ 0 = 1。

如果拿出两个白球，或者两个黑球，就重新往袋子放入一个白球。

这种情况即 0 ^ 0 = 1 ^ 1 = 0。 

<br>

最开始的袋子，我们就可以想象成有 a 个 0，b 个 1。

拿出两个数，再放回一个数。就相当于，拿出数x、y，将它们的异或结果 x ^ y = z，再放进袋子。

这个问题的实质就是 a 个 0，b 个 1 整体异或的结果是啥。

那么结果和0的个数没关系，因为无论多少个0，它们无进位相加，结果还是0。

而如果 b 是 偶数， b 个 1 无进位相加结果为0。

如果 b 是 奇数， b 个 1 无进位相加结果为1。



# 3. 题目

## 3.1 交换两个数的值

```java
public class Code01_SwapExclusiveOr {
    public static void main(String[] args) {
        int a = -10;
        int b = 2313;

        a = a ^ b;
        b = a ^ b;
        a = a ^ b;

        System.out.println(a);
        System.out.println(b);
    }
}
```

<br>

主要解释下面为什么通过下面三行代码，就可以完成两个数的值的交换。

假设一开始 a = 甲，b = 乙

执行完 a = a ^ b ，这是 a 的赋值语句，a = 甲 ^ 乙，b =  乙。

执行完b = a ^ b，a = 甲 ^ 乙，b = (甲 ^ 乙)  ^ 乙 = 甲。

执行完a = a ^ b，a = (甲 ^ 乙) ^ 甲 = 乙，b = 甲。

<br>

**注意：** 上面写法的前提是 a 和 b 必须要有自己的内存空间。



## 3.2 不用任何判断语句和比较操作，返回两个数的最大值

测试链接 : https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76

```java
public class Code02_GetMaxWithoutJudge {
    public static int flip(int n) {
        return n ^ 1;
    }


    /**
     *  负数返回0
     *  非负返回1
     */
    public static int sign(int n) {
        return flip(n >>> 31);
    }

    public static int getMax1(int a, int b) {
        int c = a - b;

        int returnA = sign(c);
        int returnB = flip(returnA);

        return a * returnA + b * returnB;
    }

    public static int getMax2(int a, int b) {
        int c = a - b;

        int sa = sign(a);
        int sb = sign(b);
        int sc = sign(c);

        int diffAB = sa ^ sb;
        int sameAB = flip(diffAB);

        int returnA = diffAB * sa + sameAB * sc;
        int returnB = flip(returnA);

        return  a * returnA + b * returnB;
    }
}
```

<br>

### flip和sign

flip 函数的参数只能接收 0 或 1，这个函数的作用是0变1，1变0。

sign 函数的作用是根据符号位，判断 n 的正负。

n 是 int类型，int 是32位。将 n 无符号右移31位，那么最高位的代表符号的那个数字，就落在了最低位上。

如果 n 是 负数，无符号右移31位，得到 1。

如果 n 是非负数，无符号右移31位，得到0。

**sign**函数中还要将无符号右移31位的结果作为参数，传递给**flip**函数。那么，

如果 n 是负数，sign(n) = 0。

如果 n 是非负数，sign(n) = 1。

<br>

### getMax1

int c = a - b; 如果 a >= b，那么 c 为非负数，否则 c 为负数。

<br>

int returnA = sign(c);

int returnB = flip(returnA);

如果 sign(c) = 1，说明 c 是非负数。说明 a 比 b 大，应该返回a。

此时 returnA = 1，returnB = 0。则最后返回结果表达式 a * returnA + b * returnB = a * 1 + b * 0 = a。

<br>

如果 sign(c) = 0，说明 c 是负数。说明 b 比 a 大，应该返回b。

此时 returnA =0，returnB = 1。则最后返回结果表达式 a * returnA + b * returnB = a * 0 + b * 1 = b。

<br>

但是这种做法会有溢出。getMax2方法解决了溢出问题。

### getMax2

sa、sb、sc 分别是a、b、c 的 符号位标志（也就是非负为1，负数为0）。 

<br>

int diffAB = sa ^ sb;

int sameAB = flip(diffAB);

如果 a 和 b同为正 或者 同为负，即符号一样，那么 diffAB  = 0 ，sameAB = 1。

如果 a 和 b 为一正一负，即符号不一样，那么diffAB  =1 ，sameAB = 0。

总之 diffAB  和 sameAB  一定是 一个为1，一个为0。它们一定不相等。

<br>

返回 a 的情况有两种：

1. a 和 b 符号不一样 且 a为非负数。
2. a 和 b 符号一样 且 c 为非负数。

<br>

int returnA = diffAB * sa + sameAB * sc;

这个算式只能加号左侧或右侧一边有效。因为  diffAB  和 sameAB  一定是 一个为1，一个为0。

如果 a 和 b 符号不一样 且 a为非负数 ，returnA = diffAB * sa = sa = 1。

如果 a 和 b 符号一样 且 c 为非负数，returnA =  sameAB * sc = sc = 1。

所以 int returnA = diffAB * sa + sameAB * sc; 就是返回a的条件。

<br>

int returnB = flip(returnA);

returnB 也就是 returnA取反。

这也很好理解，如果返回a了，肯定就不返回b。反之依然。

<br>

 最后 return  a * returnA + b * returnB;

returnA 和 returnB 也一定 一个为1，一个为0。



## 3.3 找到缺失的数字

题目：https://leetcode.cn/problems/missing-number/

有一个数组n，长度为10，索引为0 ~ 9。

现在有数字0~10，共11个数字。而数组n最多容纳10个数字。题目要求我们找到这个缺失的数字。



### 代码

```java
public class Code03_MissingNumber {
    public int missingNumber(int[] nums) {
        int xorAll = 0, xorHas = 0;

        for (int i = 0; i < nums.length; i++) {
            xorAll ^= i;
            xorHas ^= nums[i];
        }

        xorAll ^= nums.length;

        return xorAll ^ xorHas;
    }
}
```

<br>



### 思路

#### 1. 核心原理

要理解这个解法，只需要记住异或运算（符号通常为 `^` 或 $\oplus$）的三个核心性质：

1. 归零律：任何数和自己做异或运算，结果为 0。

   

   $$x \oplus x = 0$$

2. 恒等律：任何数和 0 做异或运算，结果还是它自己。

   

   $$x \oplus 0 = x$$

3. 交换律和结合律：异或运算的顺序不影响结果。

   

   $$a \oplus b \oplus c = a \oplus c \oplus b$$

#### 2. 解题思路

题目给出的数组包含 $0$ 到 $n$ 中的 $n$ 个数，唯独缺了一个。

我们可以构造两个集合：

- **集合 A**：数组中现有的所有数字（即 `nums` 中的元素）。
- **集合 B**：从 $0$ 到 $n$ 的完整数字序列（即下标 $0$ 到 $n-1$，再加上 $n$）。

如果你把 **集合 A** 和 **集合 B** 里的**所有数字**放在一起进行异或运算：

- **出现的数字**：除了那个“丢失的数字”外，其他所有数字都会出现**两次**（一次在数组里，一次在完整序列里）。根据归零律 ($x \oplus x = 0$)，它们会全部抵消变成 0。
- **丢失的数字**：只在完整序列里出现**一次**。
- **最终结果**：$0 \oplus 0 \oplus \dots \oplus \text{missing}$，根据恒等律，结果就是那个丢失的数字。



## 3.4 数组中1种数出现了奇数次，其他的数都出现了偶数次

测试链接：https://leetcode.cn/problems/single-number/

### 代码

```java
public class Code04_SingleNumber {
    public int singleNumber(int[] nums) {
        int xor = 0;

        for (int num : nums) {
            xor ^= num;
        }

        return xor;
    }
}
```

<br>

一个数，异或偶数次一定就为0了。

所以将数组中的每个元素异或，得到结果就是出现奇数次的元素。



## 3.5 数组中有2种数出现了奇数次，其他的数都出现了偶数次

测试链接：https://leetcode.cn/problems/single-number-iii/

### 代码

```java
public class Code05_DoubleNumber {
    public static int[] singleNumber(int[] nums) {
        int xor1 = 0;

        for (int num : nums) {
            xor1 ^= num;
        }

        int rightOne = (xor1) & (-xor1);

        int xor2 = 0;
        for (int i = 0; i < nums.length; i++) {
            if ( (rightOne & nums[i]) == 0 ) {
                xor2 ^= nums[i];
            }
        }

        return new int[]{xor2, xor1 ^ xor2};
    }
}
```



### 思路

#### Brian Kernighan算法

Brian Kernighan算法：提取出二进制状态中最右侧的1

对于一个数n，它的二进制为：				0 0 1 1 0 1 1 0

提取出n的二进制状态中最右侧的1：	  0 0 0 0 0 0 1 0	

<br>

这是怎么做到的呢？

n：			0 0 1 1 0 1 1 0

~n：		  1 1 0 0 1 0 0 1

~n + 1：    1 1 0 0 1 0 1 0

n & (~n + 1) = 0 0 0 0 0 0 1 0	

而 ~n + 1 是 n 的相反数，

所以 n & (~n + 1) =  n & (-n)



#### 解题思路

假设在数组中出现了奇数次的数字是a和b。我们将数组中所有的元素进行异或，最后得到的结果就是 a ^ b。

即 xor1 = a ^ b。

而xor1 一定对应一个二进制数，最右边是第0位，假设第三位为1。

那么说明a 和 b，一定有一个第三位为1，一个第三位不为1。因为只有这样，异或的结果才能导致第三位为1。

<br>

现在我们分出两大阵营，一个阵营里面的元素第三位是1，一个阵营里面的元素第三位不是1。

而第三位是1的那批数，有可能有若干出现了偶数次的数，但已经不重要了。反正它们异或后，第三位会被消掉。

而第三位不是1的那批数，也有可能有若干出现了偶数次的数，也不重要了，它们的第三位也会被消掉。

而 a 和 b 一定是分属于两个阵营的。要么第三位是1的数里有 a，那么第三位不是1的数里就一定有b。

要么就是反过来，第三位是1的数里有 b，第三位不是1的数里有a。

a 和 b 一定会因为第三位是不是1而分开。

剩下那些出现偶数次的数不用理，因为它们无论出现在哪个阵营，一定会被消掉。

<br>

再准备一个变量叫xor2。再遍历一遍整个数组。

但是 xor2 只选择第三位上不是1的数，才跟它异或。

那么 xor2 最终 等于a 或者 等于b。

<br>

也就是说，最终

xor1 = a ^ b

xor2 = a or xor2 = b

如果 xor2 = a ，那么 b = xor1 ^ xor2。

如果 xor2 = b， 那么 a = xor1 ^ xor2。



## 3.6 数组中只有1种数出现次数少于m次，其他数都出现了m次

测试链接：https://leetcode.cn/problems/single-number-ii/



### 代码

```java
public class Code06_OneKindNumberLessMtimes {
    public static int find(int[] arr, int m) {
        int[] cnts = new int[32];

        // 计算数组所有的数的每一位的1的个数
        for (int num : arr) {
            for (int i = 0; i < 32; i++) {
                cnts[i] += (num >> i) & 1;
            }
        }

        int ans = 0;
        for (int i = 0; i < 32; i++) {
            if (cnts[i] % m != 0) {
                ans = ans | (1 << i);
            }
        }

        return ans;
    }
}
```



#### 注意

ans就是我们要返回的，出现次数不足m的数。

ans 初始值为 0。

cnts[i] % m != 0 成立，说明第i位上是1，怎么让ans的第i位变成1呢？

假设 cnts[0] % m != 0，则第0位上是1，我们让 1（第0位是1） 或 ans，这样 ans 的第0位就是1了。

如果 cnts[5] % m != 0，则第5位上是1，我们让1左移5位后，或上ans，这样ans的第5位就是1了。



### 思路

一个数组中其他数出现m次，只有一种数出现不足n次。

比如说 0110 出现 m 次。

也就是说这个数的每一位提供的 1 的个数如下：

0位：	0次

1位：	m次

2位：	m次

3位：	0次

<br>

下一个数1 1 0 0 也出现了m次。

这个数和上个数提供的 1的个数的总数如下：

0位：	0	+	0次

1位：	m	+	0次

2位：	m	+	m次

3位：	0	+	m次

<br>

每一位出现1的次数都是m的整数倍。（如果一直没出现那个不够m次的数的话）

<br>

下一个数 1 0 0 1 出现了m次。

目前该数组提供的 1的个数的总数如下：

0位：	0	+	0	+	m次

1位：	m	+	0	+	0次

2位：	m	+	m	+	0次

3位：	0	+	m	+	m次

<br>

下一个数 0 0 1 1 出现了 k 次。（k < m）

如果有一种数，它不够m次，那么整体 0位上1的数量、1位上1的数量、2位上1的数量、3位上1的数量会因为这个数的出现，而不再是m的整数倍。

目前该数组提供的 1的个数的总数如下：

0位：	0	+	0	+	m	+	k次

1位：	m	+	0	+	0	+	k次

2位：	m	+	m	+	0	+	0次

3位：	0	+	m	+	m	+	0次

可以看到0位上1的数量，1位上1的数量，都不是m的倍数了。

<br>

我们可以把数组中的元素每一位的1算一个数量，某一位上如果1的数量不足m的整数倍，说明那一位上就是 **出现不够m次的数** 的状态。

至此，我们可以看到：

0位上1的数量 % m = k

1位上1的数量 % m = k

2位上1的数量 % m = 0

3位上1的数量 % m = 0

<br>

也就是说，你把数组中所有数字 的 每一位的1 累加到一个记录中，整个过程昨做完之后，你看 每一位的1有多少个，它（每一位1的个数）跟m的整数倍什么关系，如果它是m的整数倍，说明最终的数（出现次数少于m次的数）在这一位上是0，如果不是m的整数倍，说明最终的数在这一位上是1。















