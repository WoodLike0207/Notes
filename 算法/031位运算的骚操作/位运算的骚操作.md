![image-20251226235035865](%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C.assets/image-20251226235035865.png)



# 1. 判断一个整数是不是2的幂

测试链接：https://leetcode.cn/problems/power-of-two/

## 代码

```java
public class Code01_PowerOfTwo {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n == (n & (-n)));
    }   
}
```



## 思路

做这题需要掌握 Brian Kernighan 算法。

对于一个数，如果它小于0，那么它一定不是2的幂。

而大于0的数，怎么看是不是2的幂？

我们将以下2的幂转换成二进制：

2^0^ 		0001

2^1^		 0010

2^2^		 0100

2^3^		 1000

可以看到，2的幂的二进制，只有某一位上面是1。

<br>

假设 n = 0010 1000

通过Brian Kernighan 算法提取n最右侧的1，即 0000 1000。

如果提取最右侧1之后，得到的结果与n相等，说明n是2的幂。如果不相等，就不是2的幂。



# 2. 判断一个整数是不是3的幂

测试链接：https://leetcode.cn/problems/power-of-three/



## 代码

```java
public class Code02_PowerOfThree {
    public boolean isPowerOfThree(int n) {
        return n > 0 && (1162261467 % n == 0);
    }
}
```



## 思路

如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子
1162261467是int型范围内，最大的3的幂，它是3的19次方
这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么
1162261467 % n == 0
反之如果1162261467 % n != 0 说明n一定含有其他因子



# 3. 返回大于等于n的最小的2某次方

## 代码

```java
public class Code03_Near2power {
    public static int near2power(int n) {
        if (n < 0) {
            return 1;
        }

        n--;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;

        return n+1;
    }

    public static void main(String[] args) {
        int number = 100;
        System.out.println(near2power(number));
    }
}
```



## 思路

这段代码实现了一个非常经典的位运算算法。

代码功能： 给定一个整数 n，返回大于或等于 n 的最小的 2 的幂次方（Power of 2）。

例如：输入 10 返回 16，输入 8 返回 8。

这个算法在 Java 的 `HashMap` 源码中也有类似的实现（`tableSizeFor` 方法），用来保证哈希表的容量总是 2 的幂。

------

### 1. 核心逻辑图解

这段代码的核心思想是：**通过位移和或运算，把最高位 `1` 后面的所有位都变成 `1`。**

假设我们有一个二进制数，最高位的 1 在这里，后面可能有 0 也可能有 1：

001xxxxx...

经过那一连串的 >>> 和 |= 操作后，它会变成：

00111111...  (最高位以及它右边所有的位全变成了 1)

最后执行 return n + 1：

00111111... + 1 = 01000000... (这就变成了一个标准的 2 的幂)

------

### 2. 逐行代码解释

#### A. 边界判断

```java
if (n <= 0) {
    return 1;
}
```

如果 `n` 是负数或 0，直接返回 1（即 $2^0$）。因为 2 的幂次方必须是正整数。

#### B. 关键的第一步：`n--`

```java
n--;
```

为什么要减 1？

这是为了处理 n 本身就已经是 2 的幂次方的情况。

- 如果 `n = 8` (二进制 `1000`)，我们要的结果是 `8`。
- 如果不减 1，直接往下走，`1000` 经过“全变 1”的操作会变成 `1111` (15)，最后 +1 变成 `16`。这就错了。
- 减 1 后，`8` 变成 `7` (`0111`)，处理后还是 `0111`，最后 +1 变回 `8`。正确！

#### C. “铺满 1” 的过程 (Smearing)

```java
n |= n >>> 1;
n |= n >>> 2;
n |= n >>> 4;
n |= n >>> 8;
n |= n >>> 16;
```

这一步利用了倍增的思想，将最高位的 `1` 不断向右复制。

- `>>> 1`：把最高位的 1 向右复制 1 位（现在有 2 个连续的 1）。
- `>>> 2`：把这 2 个 1 再向右复制 2 位（现在有 4 个连续的 1）。
- `>>> 4`：把这 4 个 1 再向右复制 4 位（现在有 8 个 continuous 1）。
- ...
- 直到 `>>> 16`：因为 Java 的 `int` 是 32 位的，移动 16 位后，一定能覆盖满整个 32 位长度。

#### D. 返回结果

```java
return n + 1;
```

此时 `n` 的二进制形式类似于 `00011111`。加 1 后变成 `00100000`，即目标 2 的幂。

------

### 3. 用例演示 (Trace)

#### 用例 1：输入 `n = 10`

目标：返回 16。

1. **初始**: `n = 10` (二进制 `0000 1010`)

2. **`n--`**: `n = 9` (二进制 `0000 1001`)

3. **位运算过程**:

   - `n >>> 1`: `0000 0100`
   - `n |= ...`: `0000 1001` | `0000 0100` = `0000 1101` (前两位变成了 1)
   - `n >>> 2`: `0000 0011`
   - `n |= ...`: `0000 1101` | `0000 0011` = `0000 1111` (前四位变成了 1)
   - 之后的 `>>> 4, 8, 16`，由于低位已经是 1，结果保持 `0000 1111` (即 15) 不变。

4. return n + 1: 15 + 1 = 16。

   结果正确。

#### 用例 2：输入 `n = 16` (已经是 2 的幂)

目标：返回 16。

1. **初始**: `n = 16` (`0001 0000`)

2. **`n--`**: `n = 15` (`0000 1111`)

3. **位运算过程**:

   - 因为 `15` 的二进制已经是 `1111` 了，无论怎么右移和或运算，它始终保持 `0000 1111`。

4. return n + 1: 15 + 1 = 16。

   结果正确。 (这就是开头 n-- 的作用)

#### 用例 3：输入n= `Integer.MAX_VALUE`

Integer.MAX_VALUE 是 $2^{31} - 1$，即 2147483647。

1. **初始**: `01111111 11111111 11111111 11111111` (31个1)
2. **`n--`**: `01111111 ... 11111110` (末尾变0)
3. **位运算**: 经过一通操作，所有的空隙都被填满，变回 `01111111 ... 11111111`。
4. **`return n + 1`**:
   - `Integer.MAX_VALUE + 1` 会发生**整型溢出 (Overflow)**。
   - 二进制变成 `10000000 00000000 00000000 00000000`。
   - 在 Java `int` (有符号数) 中，这是 `Integer.MIN_VALUE` (即 -2147483648)。

> "如果int范围内不存在这样的数，返回整数最小值"

输出结果应该是 `-2147483648`。



# 4. 区间 [left, right] 内所有数字 & 的结果

 给你两个整数 left 和 right ，表示区间 [left, right]，返回此区间内所有数字 & 的结果。

测试链接 : https://leetcode.cn/problems/bitwise-and-of-numbers-range/

## 代码

```java
public class Code04_LeftToRightAnd {
    public static int rangeBitwiseAnd(int left, int right) {
        while (left < right) {
            right -= right & (-right);
        }

        return right;
    }
}
```



## 思路

这段代码是 **LeetCode 201题 [数字范围按位与](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)** 的一种非常巧妙的解法。

### 1. 代码功能与核心思想

**功能**：给定两个整数 `left` 和 `right`，计算区间 `[left, right]` 内所有数字按位与（AND）的结果。

核心思想：

在一个连续的数字区间里，只要某个二进制位发生了变化（从 0 变成 1，或者从 1 变成 0），那么在这个区间所有数字的“按位与”结果中，这一位一定是 0。

因此，这个题目的本质是：求 left 和 right 的二进制“公共前缀”（即高位相同的部分，后面全补 0）。



### 2. 代码逻辑解析

#### 关键操作：`right -= right & -right`

这一行代码利用了 **Lowbit** 操作。

- `right & -right`：取出 `right` 二进制中最右边的一个 `1`（例如 `6(110)` -> `2(010)`）。
- `right -= ...`：把这个 `1` 减掉，相当于把 `right` 最右边的 `1` 变成了 `0`。

算法流程：

不断的把 right 最右边的 1 抹去，直到 right 小于等于 left 为止。因为 left 和 right 的公共前缀一定小于等于 left，而把 right 的低位 1 抹去的过程，就是在逼近这个公共前缀。

------

### 3. 用例演示 (Trace)

#### 用例 1：`left = 5`, `right = 7`

二进制视角：

- `left` = `101` (5)
- `right` = `111` (7)
- 区间包含：5 (`101`), 6 (`110`), 7 (`111`)。
- **按位与结果**：`100` (4)。

**代码执行过程**：

1. **初始**：`left = 5`, `right = 7`。满足 `5 < 7`，进入循环。

2. **第一次循环**：

   - `right` (7) 的二进制是 `111`。
   - `right & -right` (Lowbit) 是 `001` (1)。
   - `right` 更新为 `7 - 1 = 6` (`110`)。

3. **检查条件**：`5 < 6`，满足，继续循环。

4. **第二次循环**：

   - `right` (6) 的二进制是 `110`。
   - `right & -right` (Lowbit) 是 `010` (2)。
   - `right` 更新为 `6 - 2 = 4` (`100`)。

5. **检查条件**：`5 < 4`，**不满足**。

6. 返回：4。

   结果正确！

#### 用例 2：`left = 26`, `right = 30`

二进制视角：

- `left` = `11010` (26)
- `right` = `11110` (30)
- 公共前缀是前面的 `11`，后面补0，预期结果是 `11000` (24)。

**代码执行过程**：

1. **初始**：`26 < 30`。

2. **Loop 1**：

   - `30 (11110)` 抹去最右边的 1 (值为2)。
   - `right` 变为 `28 (11100)`。
   - `26 < 28`，继续。

3. **Loop 2**：

   - `28 (11100)` 抹去最右边的 1 (值为4)。
   - `right` 变为 `24 (11000)`。
   - `26 < 24`，**不满足**。

4. 返回：24。

   结果正确！

### 4. 总结

这个算法比简单的“逐位右移”更高效，因为它跳过了中间所有的 `0`，每次循环通过 `right & -right` 直接消除一个 `1`。

- **时间复杂度**：最坏情况是 `O(位数)`，即 32 次（对于 int），但实际上远少于此，因为只处理为 1 的位。
- **应用场景**：处理区间位运算、IP地址掩码计算等需要找公共二进制前缀的问题。



# 5. 逆序二进制的状态

测试链接 : https://leetcode.cn/problems/reverse-bits/

## 代码

```java
public class Code05_ReverseBits {
    public static int reverseBits(int n) {
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
        n = (n >>> 16) | (n << 16);
        return n;
    }
}
```



## 思路

题意是这样的，假设有一个数的二进制状态是 a b c d e f g h。

逆序二进制为：h g f e d c b a。

这个逆序二进制是怎么得到的呢？

先进行1v1，也就是两两交换：

b a d c f e h g

然后2v2：

d c b a h g f e

最后4v4：

h g f e d c b a

<br>

可上面这个过程我们又怎么用代码实现呢？



### 1v1

先让 a b c d e f g h 与 1 0 1 0 1 0 1 0 相与，得到a 0 c 0 e 0 g 0：

​		a b c d e f g h

​	& 1 0 1 0 1 0 1 0

​		a 0 c 0 e 0 g 0

1 0 1 0 1 0 1 0 用16进制表示就是aa。

我们这里用8位举例，而int是32位，所以代码上是和0xaaaaaaaa相与。

<br>

再让  a b c d e f g h 与 0 1 0 1 0 1 0 1 相与，得到 0 b 0 d 0 f 0 h：

​		a b c d e f g h

​	& 0 1 0 1 0 1 0 1

​		0 b 0 d 0 f 0 h

0 1 0 1 0 1 0 1 用16进制表示就是 55。

代码上是0x55555555。

<br>

a 0 c 0 e 0 g 0 右移1位，得到 0 a 0 c 0 e 0 g 

0 b 0 d 0 f 0 h 左移1位，得到 b 0 d 0 f 0 h 0

它们进行或运算，得到 1v1 的结果，即b a d c f e h g：

​		0 a 0 c 0 e 0 g 

   |   b 0 d 0 f 0 h 0

​		b a d c f e h g



### 2v2

现在是：b a d c f e h g

b a d c f e h g 和 1 1 0 0 1 1 0 0 相与，得到 b a 0 0 f e 0 0：

​		b a d c f e h g

​	& 1 1 0 0 1 1 0 0

​		b a 0 0 f e 0 0

1 1 0 0 1 1 0 0 用16进制表示就是 cc。

代码上写的是0xcccccccc。

<br>

b a d c f e h g  和 0 0 1 1 0 0 1 1相与，得到 0 0 d c 0 0 h g：

​		b a d c f e h g

​	& 0 0 1 1 0 0 1 1

​		0 0 d c 0 0 h g

0 0 1 1 0 0 1 1 用16进制表示就是 33。

代码上写的是 0x33333333。

<br>

b a 0 0 f e 0 0 右移两位，得到 0 0 b a 0 0 f e。

0 0 d c 0 0 h g 左移两位，得到 d c 0 0 h g 0 0。

它们进行或运算，得到 2v2 的结果，即 d c b a h g f e：

​		0 0 b a 0 0 f e 

   |   d c 0 0 h g 0 0

​		d c b a h g f e

<br>

### 4v4

现在是：d c b a h g f e

d c b a h g f e 和 1 1 1 1 0 0 0 0相与，得到 d c b a 0 0 0 0：

​		d c b a h g f e

​	& 1 1 1 1 0 0 0 0

​		d c b a 0 0 0 0

 1 1 1 1 0 0 0 0 用16进制表示就是 f0。

代码上写的是 0xf0f0f0f0。

<br>

d c b a h g f e 和 0 0 0 0 1 1 1 1相与，得到 0 0 0 0 h g f e：

​		d c b a h g f e

​	& 0 0 0 0 1 1 1 1

​		0 0 0 0 h g f e

0 0 0 0 1 1 1 1 用16进制表示就是 0f。

代码上写的是 0x0f0f0f0f。

<br>

d c b a 0 0 0 0 右移四位，得到 0 0 0 0 d c b a。

0 0 0 0 h g f e 左移四位，得到 h g f e 0 0 0 0。

<br>

它们进行或运算，得到 4v4 的结果，即 ：

​		0 0 0 0 d c b a

​	|  h g f e 0 0 0 0

​		h g f e d c b a

<br>

我们这个例子，只到了8位就结束了。

而int是32位的，所以我们的代码必须接下来将32位换完。

如果是32位数，遇到8v8，那么这个数应该先与（8个1，8个0，8个1，8个0）得到结果1，再与（8个0，8个1，8个0，8个1）得到结果2。结果1 和 结果2进行或运算。

代码最后16v16的时候，没有进行与运算，直接移位，是因为int是32位，你移了16位，剩下的自动补0。



# 6. 返回n的二进制中有几个1

测试链接 : https://leetcode.cn/problems/hamming-distance/

## 代码

```java
public class Code06_CountOnesBinarySystem {
    public static int cntOnes(int n) {
        n = (n & 0x55555555) + ((n >>> 1) & (0x55555555));
        n = (n & 0x33333333) + ((n >>> 2) & (0x33333333));
        n = (n & 0x0f0f0f0f) + ((n >>> 4) & (0x0f0f0f0f));
        n = (n & 0x00ff00ff) + ((n >>> 8) & (0x00ff00ff));
        n = (n & (0x0000ffff)) + ((n >>> 16) & (0x0000ffff));

        return n;
    }
}
```



## 思路

这是一个非常经典的位操作算法，通常被称为 **“分治法求二进制中1的个数”**（Divide and Conquer Population Count），或者叫 **Hamming Weight** 算法。

Java的标准库 `Integer.bitCount()` 方法内部也是利用了类似的原理（做了一点点优化）。

### 核心原理：并行加法

这个算法的核心思想不是“一个一个数”，而是**“两两合并，四四合并，八八合并……”**。它把原本的数字看作是由很多个小容器组成的，每个容器里装着当前位置的 1 的个数，然后不断把相邻的容器里的数加起来。

### 8位二进制详细图解

为了让你更容易理解，我们按照你的要求，只用 **8位（1字节）** 来演示。

假设我们要计算数字 211 中有多少个 1。

211 的二进制是：11010011 （我们可以一眼看出有 5 个 1，现在看代码怎么算出来）。

#### 步骤 1：两两一组，计算每 2 位中有几个 1

代码对应：n = (n & 0x55) + ((n >>> 1) & 0x55);

注：32位是 0x55555555，8位就是 0x55 (二进制 01010101)。

这一步是把每两个 bit 看作一组，计算这组里有几个 1，并把结果存回这两个 bit 的位置。

- **原始数据**： `1 1 | 0 1 | 0 0 | 1 1`
- **物理含义**：
  - 第1组 `11`：有两个1 (二进制 `10`)
  - 第2组 `01`：有一个1 (二进制 `01`)
  - 第3组 `00`：有零个1 (二进制 `00`)
  - 第4组 `11`：有两个1 (二进制 `10`)
- **代码运算过程**：
  1. `n & 0x55` (取出奇数位作为值): `01010101` & `11010011` -> `01010001`
  2. `n >>> 1` (将偶数位移到奇数位): `01101001`
  3. `& 0x55` (清洗多余位): `01000001`
  4. **相加**：`01010001` + `01000001` = **`10010010`**
- **结果解读**：
  - 二进制：`10 01 00 10`
  - 含义：`2` `1` `0` `2` （第一组有2个，第二组有1个...）

#### 步骤 2：四四一组，计算每 4 位中有几个 1

代码对应：n = (n & 0x33) + ((n >>> 2) & 0x33);

注：32位是 0x33333333，8位就是 0x33 (二进制 00110011)。

现在我们把相邻的“2位计数组”加起来，存放到“4位”的空间里。

- **当前数据**： `1001 | 0010` (即上一步的结果 `2` `1` | `0` `2`)
- **物理含义**：
  - 左边4位：要算 `2 + 1 = 3` (二进制 `0011`)
  - 右边4位：要算 `0 + 2 = 2` (二进制 `0010`)
- **代码运算过程**：
  1. `n & 0x33`: `10010010` & `00110011` -> `00010010` (保留了低位的计数)
  2. `n >>> 2`: `00100100`
  3. `& 0x33`: `00100000` (取出了高位的计数)
  4. **相加**：`00010010` + `00100000` = **`00110010`**
- **结果解读**：
  - 二进制：`0011 0010`
  - 含义：`3` `2` （左边4位总共有3个1，右边4位总共有2个1）

#### 步骤 3：八八一组，计算每 8 位中有几个 1

代码对应：n = (n & 0x0f) + ((n >>> 4) & 0x0f);

注：32位是 0x0f0f0f0f，8位就是 0x0f (二进制 00001111)。

最后，把两个“4位计数组”加起来，放到“8位”里。

- **当前数据**： `00110010` (即 `3` 和 `2`)
- **物理含义**：
  - 计算 `3 + 2 = 5`
- **代码运算过程**：
  1. `n & 0x0f`: `00110010` & `00001111` -> `00000010` (取右边的2)
  2. `n >>> 4`: `00000011`
  3. `& 0x0f`: `00000011` (取左边的3)
  4. **相加**：`00000010` + `00000011` = **`00000101`**
- **最终结果**：
  - 二进制：`00000101`
  - 十进制：**5**

答案正确！

### 总结掩码（Mask）的规律

代码中那些看起来很奇怪的十六进制数，其实就是特定形状的“筛子”：

1. **`0x55555555` (0101...)**:
   - `0` `1` `0` `1`...
   - 作用：每 **1** 位隔开，负责处理 **2** 位以内的加法。
2. **`0x33333333` (0011...)**:
   - `00` `11` `00` `11`...
   - 作用：每 **2** 位隔开，负责处理 **4** 位以内的加法。
3. **`0x0f0f0f0f` (00001111...)**:
   - `0000` `1111`...
   - 作用：每 **4** 位隔开，负责处理 **8** 位以内的加法。
4. **`0x00ff00ff`**: 负责 16 位以内的加法。
5. **`0x0000ffff`**: 负责 32 位以内的加法。

### 为什么不用循环？

如果用循环（比如 for 循环 32 次，或者用 n & (n-1)），你需要做很多次判断和跳转。

而这个算法没有循环（Loop-free），全是位运算和加法，CPU 处理起来非常快，并且执行时间是固定的，不会因为 1 的多或少而改变耗时。



































