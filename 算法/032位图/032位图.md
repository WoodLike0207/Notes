![image-20251228143424285](032%E4%BD%8D%E5%9B%BE.assets/image-20251228143424285.png)



# 位图原理

位图（**Bitmap** 或 **Bitset**）的原理其实非常简单直观，它的核心思想就是：**用一个 bit 位（0 或 1）来标记某个元素是否存在。**

通常我们存一个数字 `int` 需要 4 个字节（32 bit），但在位图中，存一个数字只需要 **1 个 bit**。这让它在处理海量数据时，拥有极其可怕的空间压缩能力。

------

### 1. 核心思想：把“值”映射为“下标”

想象你有一排开关（灯泡），每个开关下面都有一个编号：0, 1, 2, 3, 4, ...

- 如果你想存数字 **3**，你就把编号为 **3** 的开关打开（置为 1）。
- 如果你想存数字 **5**，你就把编号为 **5** 的开关打开。
- 如果你想查询 **3** 在不在，你就看编号为 **3** 的开关是不是亮着的。

在这个系统中：

- **下标（Index）** 代表 **数值本身**。
- **值（Value 0/1）** 代表 **是否存在**。

### 2. 具体实现：如何定位？

计算机内存最小寻址单位是字节（Byte，8 bit），没有办法直接定义一个“位数组”。所以我们通常用一个 `byte[]` 或 `int[]` 数组来模拟。

假设我们用 byte[] 数组来实现位图。

我们要存数字 $N$，需要解决两个问题：

1. **数组下标**：$N$ 在第几个字节里？
2. **位偏移量**：$N$ 在该字节的第几位？

#### 公式

- **数组下标** = $N / 8$ （或者 `N >> 3`）
- **位偏移量** = $N \% 8$ （或者 `N & 7`）

------

### 3. 用例演示（还是用 8 位举例）

假设我们有一个 `byte[] bits` 数组，现在我们要存入数字 **13**。

**第一步：定位**

- **数组下标**：$13 / 8 = 1$。说明 13 落在 `bits[1]` 这个字节里。
- **位偏移量**：$13 \% 8 = 5$。说明 13 对应 `bits[1]` 的第 5 位（从右往左数，从0开始）。

第二步：操作（置 1）

我们要把 bits[1] 的第 5 位置为 1。

这需要用到**按位或（OR）**操作。

1. 准备一个只有第 5 位是 1 的“掩码”：`1 << 5` (即二进制 `00100000`)。
2. 将这个掩码与 `bits[1]` 做**或运算**：`bits[1] = bits[1] | (1 << 5)`。

图解：

假如 bits[1] 原本是 00000000：

Plaintext

```
   00000000  (bits[1] 原值)
|  00100000  (1 << 5)
-----------
   00100000  (新值)
```

这就把 13 存进去了。

第三步：查询（Get）

现在我们要问：13 存在吗？

1. 找到位置：`bits[1]` 的第 5 位。
2. 做**按位与（AND）**检查：`(bits[1] & (1 << 5))`。
3. 如果结果不为 0，说明存在；为 0，说明不存在。

------

### 4. 空间优势对比

这就很惊人了。假设我们要处理 **20 亿** 个整数（假设是连续的）：

- 普通数组 (int[])：

  每个数字 4 字节。

  $20亿 \times 4 \text{ Bytes} \approx 8 \text{ GB}$

  内存直接爆炸。

- 位图 (Bitmap)：

  每个数字 1 比特。

  $20亿 \text{ bits} / 8 = 2.5亿 \text{ Bytes} \approx 238 \text{ MB}$

  8GB 变成了 238MB，完全可以放进内存。

### 5. 实际应用场景（Java & Redis）

既然你是 Java 开发者，这些场景你一定很眼熟：

1. **用户签到 (Redis `setbit`)**
   - 把用户的 ID 作为 Key，每一天对应位图中的一位。
   - 第 1 天签到，把第 1 位置 1；第 300 天签到，把第 300 位置 1。
   - 一年的签到记录只需要 365 bits ≈ 46 字节。
   - **统计签到天数**：直接调用 `bitcount` 命令（这底层就是你刚才问的那个算法 `cntOnes`！）。
2. **布隆过滤器 (Bloom Filter)**
   - 这是位图的进阶版。用来判断“一个元素一定不存在，或者可能存在”。
   - 防止缓存穿透的神器。它利用多个哈希函数把数据映射到位图的不同位置。
3. **Java JDK 中的 `BitSet`**
   - Java 自带了 `java.util.BitSet`，底层就是用 `long[]` 实现的位图。它帮你封装好了 `set()`, `get()`, `cardinality()` 等方法，不用自己写移位操作。

### 总结

- **原理**：利用 bit 位代表状态，下标代表数值。
- **核心操作**：除法定数组下标，取模定位内偏移，位运算修改状态。
- **优点**：极致省空间，查询极快 O(1)。
- **缺点**：处理**稀疏数据**很浪费（比如只存一个数 `10亿`，你也得开辟 10亿个 bit 的空间，虽然中间全是 0），且只能存整数。



# 位图的实现



## 代码

```java
public class Code01_Bitset {
    public static class Bitset{
        public int[] bitset;

        public Bitset(int size) {
            this.bitset = new int[(size + 31) / 32];
        }

        public void add(int num) {
            bitset[num/32] |= 1 << (num % 32);
        }

        public void remove(int num) {
            bitset[num/32] &= ~(1 << (num % 32));
        }

        public void reverse(int num) {
            bitset[num/32] ^= (1 << (num % 32));
        }

        public boolean contains(int num) {
            return ((bitset[num/32] >>> (num % 32)) & 1) == 1;
        }
    }
}
```

<br>



## 分析



### 1. Bitset(int size)



#### this.bitset = new int[(size + 31) / 32];



这是一个在 C、C++、Java 等语言中非常常用的**整数向上取整**（Ceiling Division）的技巧。

因为在计算机的整数运算中，直接除法 `a / b` 默认是 **向下取整**（Truncate/Floor）的（例如 `5 / 2 = 2`）。

这个公式 `(a + b - 1) / b` 的核心逻辑是：**利用 `b-1` 作为一个“垫脚石”，如果 `a` 有余数，就把它“顶”到下一个整数；如果没有余数，则保持原样。**

我们可以分两种情况来完美解释它：

#### 情况 1：a 能够被 b 整除（余数为 0）

假设 a = 12，b = 4。

我们期望的结果是：12 / 4 = 3。

套用公式：

$$(12 + 4 - 1) / 4 \\ = (15) / 4$$

在整数除法中，`15 / 4` 的结果依然是 **3**。

分析：

因为 b-1（这里是 3）比除数 b（这里是 4）小。所以，对于一个本来就能整除的数，加上一个比除数小的数，不足以让商增加 1。它被整数除法的“向下取整”特性给截断了。

------

#### 情况 2：a 不能被 b 整除（余数 > 0）

假设 a = 13，b = 4。

正常除法：13 / 4 = 3。

但我们要向上取整，期望结果是 4。

套用公式：

$$(13 + 4 - 1) / 4 \\ = (16) / 4$$

结果是 **4**。符合预期！

分析：

这里的关键在于：只要 a 有余数（哪怕余数只是 1），它加上 b-1 之后，就会大于等于 b。

- 余数最小是 1：`1 + (b-1) = b`。刚好够凑成一个新的“1”。
- 这就相当于给分子增加了一个 `b` 的量，从而让商增加了 1。

------

#### 为什么是 `b-1` 而不是 `b`？

你可能会想，为什么要加 `b-1`？

- 如果加 b：

  也就是 (a + b) / b。这等价于 a/b + 1。

  这对于不能整除的情况是对的（比如 13/4 变成了 3+1=4）。

  但是对于能整除的情况就错了（比如 12/4 变成了 3+1=4，多加了 1）。

- 所以必须是 b-1：

  这是“最大的、不会改变整除结果”的增量。它是临界点。



### 2.  定位逻辑（贯穿所有方法）

在所有方法中，都出现了这两个算式，这是位图的核心坐标系：

1. **`num / 32` (数组下标)**：确定 `num` 住在哪个“房间”（哪个 `int` 元素）。
2. **`num % 32` (位偏移量)**：确定 `num` 是这个房间里的第几号床位（第几个 bit）。



### 3. `add` 方法（标记为 1）

```java
public void add(int num) {
    set[num / 32] |= 1 << (num % 32);
}
```

- **目标**：把对应位置的 bit 变成 **1**。

- **操作**：**按位或 (`|`)**。

- **原理**：任何数 `OR 1` 都是 1；`OR 0` 保持不变。

- **图解**（假设操作第 2 位）：

  ```java
    00100100  (原数据)
  | 00000100  (1 << 2, 只有第2位是1)
  ----------
    00100100  (第2位被强制置为1，其他位不变)
  ```

  *(注：这里第2位本来就是1，所以不变；如果是0就会变1)*

------



###  4. `remove` 方法（标记为 0）

```java
public void remove(int num) {
    set[num / 32] &= ~(1 << (num % 32));
}
```

- **目标**：把对应位置的 bit 变成 **0**。

- **操作**：**按位与 (`&`)** 配合 **取反 (`~`)**。

- **原理**：

  1. `1 << (num % 32)` 得到 `00001000` (假设是第3位)。
  2. **`~` 取反** 得到掩码：`11110111` (只有目标位是0，全是保镖)。
  3. **`&` 运算**：目标位遇到 0 变成 0；其他位遇到 1 保持原样。

- **图解**：

  ```java
    10101110  (原数据)
  & 11110111  (掩码: ~(1<<3))
  ----------
    10100110  (第3位被强制置为0，其他位完好无损)
  ```

------



###  5. `reverse` 方法（状态翻转）

```java
public void reverse(int num) {
    set[num / 32] ^= 1 << (num % 32);
}
```

- **目标**：如果是 1 变 0，如果是 0 变 1。
- **操作**：**按位异或 (`^`)**。
- **原理**：
  - `1 ^ 1 = 0`
  - `0 ^ 1 = 1`
  - 结论：**任何数和 1 异或，相当于取反；和 0 异或，保持不变。**
- **场景**：比如某些开关逻辑，点一下开，再点一下关。

------



### 6. `contains` 方法（查询状态）

```java
public boolean contains(int num) {
    return ((set[num / 32] >> (num % 32)) & 1) == 1;
}
```

- **目标**：查看那一位是 0 还是 1。

- **策略**：把目标位**移到最右边（最低位）**，然后和 `1` 做与运算。

- **步骤**：

  1. `set[...] >> k`：把第 k 位移到第 0 位（最右边）。
  2. `... & 1`：把除了最右边这一位之外的所有位都“抹零”。
  3. 判断结果是 0 还是 1。

- **图解**（假设查第 5 位）：

  ```java
  原数据:   ...101[1]00000   (目标是括号里的1)
  右移5位:  ...00000101[1]   (移到了最右边)
  & 1   :  ...00000000[1]   (清空高位)
  结果  :  1 (即 true)
  ```



# 其他测试

![image-20251228193412347](032%E4%BD%8D%E5%9B%BE.assets/image-20251228193412347.png)

测试链接：https://leetcode-cn.com/problems/design-bitset/

```java
/**
 * @Title: Code02_DesignBitsetTest
 * @Author Wood
 * @Package PACKAGE_NAME
 * @Date 2025/12/28 19:53
 * @description:
 */
public class Code02_DesignBitsetTest {
    class Bitset {
        private int[] set;
        private int size;
        private int zeros;
        private int ones;
        private boolean reverse;


        public Bitset(int size) {
            set = new int[(size + 31) / 32];
            this.size = size;
            this.zeros = size;
            this.ones = 0;
            this.reverse = false;
        }

        public void fix(int i) {
            int index = i / 32;
            int bit = i % 32;

            if (!reverse) {
                if ((set[index] & (1 << bit)) == 0) {
                    zeros--;
                    ones++;
                    set[index] |= (1 << bit);
                }
            }else {
                if ((set[index] & (1 << bit)) != 0) {
                    zeros--;
                    ones++;
                    set[index] ^= (1 << bit);
                }
            }
        }

        public void unfix(int i) {
            int index = i / 32;
            int bit = i % 32;

            if (!reverse) {
                if ((set[index] & (1 << bit)) != 0) {
                    ones--;
                    zeros++;
                    set[index] ^= (1 << bit);
                }
            }else {
                if ((set[index] & (1 << bit)) == 0) {
                    ones--;
                    zeros++;
                    set[index] |= (1 << bit);
                }
            }
        }

        public void flip() {
            reverse = !reverse;
            int tmp = ones;
            ones = zeros;
            zeros = tmp;
        }

        public boolean all() {
            return ones == size;
        }

        public boolean one() {
            return ones > 0;
        }

        public int count() {
            return ones;
        }

        public String toString() {
            StringBuilder builder = new StringBuilder();
            for (int i = 0, k = 0, number, status; i < size; k++) {
                number = set[k];
                for (int j = 0; j < 32 && i < size; j++,i++) {
                    status = (number >> j) & 1;
                    status ^= reverse ? 1 : 0;
                    builder.append(status);
                }
            }
            return builder.toString();
        }
    }
}
```





