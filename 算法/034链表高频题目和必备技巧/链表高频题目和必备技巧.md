![image-20260101164940093](%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7.assets/image-20260101164940093.png)

<br>

![image-20260101165028835](%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%A2%98%E7%9B%AE%E5%92%8C%E5%BF%85%E5%A4%87%E6%8A%80%E5%B7%A7.assets/image-20260101165028835.png)



# 1. 返回两个无环链表相交的第一个节点

测试链接 : https://leetcode.cn/problems/intersection-of-two-linked-lists/



## 代码

```java
public class Code01_IntersectionOfTwoLinkedLists {
    public static class ListNode {
        public int val;
        public ListNode next;
    }

    public static ListNode getIntersectionNode(ListNode h1, ListNode h2) {
        if (h1 == null || h2 == null) {
            return null;
        }

        int diff = 0;
        ListNode a = h1, b = h2;

        while (a.next != null) {
            a = a.next;
            diff++;
        }

        while (b.next != null) {
            b = b.next;
            diff--;
        }

        if (a != b) {
            return null;
        }

        if (diff >= 0) {
            a = h1;
            b = h2;
        }else {
            a = h2;
            b = h1;
        }

        diff = Math.abs(diff);
        while (diff-- > 0) {
            a = a.next;
        }

        while (a != b) {
            a = a.next;
            b = b.next;
        }

        return a;

    }
}
```



## 思路



### 1. 【一句话核心】

**“长短对齐法”**：两条链表如果相交，尾巴一定是共用的（Y字型）。先算出两条链表的长度差，让长的那条先走完差值步数，然后两个指针一起走，相遇点就是交点。

### 2. 【左神算法“骚”操作】

- **并不需要真正的长度**：不需要分别算出 `lenA` 和 `lenB`。只用一个变量 `diff`，A 走的时候 `++`，B 走的时候 `--`，最后 `diff` 的绝对值就是长度差。
- **复用变量**：代码中复用了 `a` 和 `b` 两个指针。最开始它们是探路者（找尾节点），后来它们变身为定位者（找交点）。
- **快速失败（Fast Fail）**：在找长度的过程中，顺便看一眼**尾节点是否相同**。如果尾节点不同，说明这俩是平行的（或者像 '||' 这样），根本没相交，直接返回 null，没必要做后面的对齐操作。

### 3. 【图解原理】

假设：

- **链表 A** (长): `1 -> 2 -> 3 -> 4 -> 5`
- **链表 B** (短):           `8 -> 4 -> 5`
- **交点**：节点 `4`

**步骤演示：**

1. **第一轮遍历**：
   - 指针 `a` 走到 `5`，`diff` 累加。
   - 指针 `b` 走到 `5`，`diff` 累减。
   - **关键点**：此时 `a` 和 `b` 都停在 `5`。`a == b`，说明有戏（相交）。
2. **计算差值**：
   - A 走了 4 步，B 走了 2 步。`diff` = 2。说明 A 比 B 长 2。
3. **重置与对齐**：
   - 重置 `a` 回到 A 头，`b` 回到 B 头。
   - **长链表先行**：`a` 先走 2 步，来到节点 `3`。
4. **齐头并进**：
   - `a` 在 `3`，`b` 在 `8`。
   - 大家一起走一步：`a` 到 `4`，`b` 到 `4`。
   - **相遇！** 返回 `4`。

------

### 4. 【代码逐行精读】

```java
public static ListNode getIntersectionNode(ListNode h1, ListNode h2) {
    if (h1 == null || h2 == null) {
        return null;
    }
    ListNode a = h1, b = h2;
    int diff = 0; // 用来记录差值

    // [Step 1] 遍历 A，计算长度并找到 A 的尾巴
    // 注意：这里用 next != null，所以循环结束时，a 停在最后一个节点上
    while (a.next != null) {
        a = a.next;
        diff++; // 统计 A 的步数
    }

    // [Step 2] 遍历 B，减去长度并找到 B 的尾巴
    while (b.next != null) {
        b = b.next;
        diff--; // 减去 B 的步数，剩下的就是 (LenA - LenB)
    }

    // [Step 3] 核心判断：如果两个链表相交，它们的尾节点必须是同一个！
    // 如果尾巴都不一样，说明是个 '||' 形状，直接拜拜
    if (a != b) {
        return null;
    }

    // [Step 4] 重新分配角色：a 变成长链表的头，b 变成短链表的头
    // 这种写法也是左神常用的：谁长谁就是 a，谁短谁就是 b
    if (diff >= 0) { // diff >= 0 说明 h1 长
        a = h1;
        b = h2;
    } else { // 否则 h2 长
        a = h2;
        b = h1;
    }

    // 取绝对值，因为我们只需要知道差几步
    diff = Math.abs(diff);

    // [Step 5] 长链表 (a) 先走 diff 步
    while (diff-- != 0) {
        a = a.next;
    }

    // [Step 6] 两个指针一起走，相遇的地方就是交点
    // 因为前面已经对其了，长度此时逻辑上相等
    while (a != b) {
        a = a.next;
        b = b.next;
    }
    return a;
}
```

### 5. 【复习闪卡 (Flashcard)】

*(下次复习时，遮住代码，问自己这 3 个问题)*

1. **Q: 怎么判断两个无环链表是否相交？**
   - A: 遍历到底，看**最后一个节点**（Tail）内存地址是否相同。
2. **Q: 为什么代码里用 `diff` 一个变量就够了，不用 `lenA` 和 `lenB`？**
   - A: 我们只关心差值。A 遍历时 `+1`，B 遍历时 `-1`，最后剩下的就是差值。
3. **Q: 在指针移动前，必须要做的关键一步是什么？**
   - A: 让**长链表的指针先走** `diff` 步，实现“起跑线对齐”。



# 2. 每k个节点一组翻转链表

测试链接：https://leetcode.cn/problems/reverse-nodes-in-k-group/

## 代码

```java
public class Code02_ReverseNodesInkGroup {
    public static class ListNode {
        public int val;
        public ListNode next;
    }

    public static ListNode reverseKGroup(ListNode head, int k) {
        ListNode start = head;
        ListNode end = teamEnd(start, k);
        if (end == null) {
            return head;
        }

        head = end;
        reverse(start, end);

        ListNode lastTeamEnd = start;
        while (lastTeamEnd.next != null) {
            start = lastTeamEnd.next;
            end = teamEnd(start,k);

            if (end == null) {
                return head;
            }

            reverse(start,end);
            lastTeamEnd.next = end;
            lastTeamEnd = start;
        }

        return head;
    }

    public static ListNode teamEnd(ListNode s, int k) {
        while (s != null && --k != 0) {
            s = s.next;
        }
        return s;
    }

    public static void reverse(ListNode s, ListNode e) {
        e = e.next;
        ListNode pre = null, cur = s, next = null;
        while (cur != e) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }

        s.next = e;
    }
}
```



## 思路

### 1. 【一句话核心】

**“打包处理，断点续连”**：先把前 K 个节点看作一个独立的子链表进行翻转，然后把翻转后的“新尾巴”和下一组的“新头”接上，如果剩余节点不够 K 个就不动。

### 2. 【算法关键技巧】

- **Probe（探针）思想**：在动工翻转之前，先写一个 `teamEnd` 方法去“探路”。看当前往后数能不能凑够 K 个。凑不够？直接返回 `head`（不翻转）；凑够了？那就动手。
- **定界翻转**：写一个特殊的 `reverse(start, end)` 方法。
  - 普通的翻转是翻转整个链表直到 `null`。
  - 这里的翻转是在 `start` 和 `end` 之间进行的，并且翻转后会自动把 `start`（变成了尾巴）连上 `end` 后面的节点。
- **头节点特殊处理**：第一组翻转最为特殊，因为**整个链表的头（Head）会变**。第一组翻转后的“新头”，就是最终返回的 `head`。

### 3. 【图解原理】

假设链表：`1 -> 2 -> 3 -> 4 -> 5`，`k = 2`。

1. **第一组 (1, 2)**：
   - `start`=1, `end`=2。
   - 翻转前：`1 -> 2 -> 3...`
   - 翻转后：`2 -> 1 -> 3...` (1 连上了 3)
   - **特殊**：因为是第一组，所以全局 `head` 变成了 2。记录 `lastTeamEnd` = 1 (上一组的结尾)。
2. **第二组 (3, 4)**：
   - `start`=3, `end`=4。
   - 翻转前：`...1 -> 3 -> 4 -> 5`
   - 翻转后：`...1` (断开) `4 -> 3 -> 5`
   - **连接**：`lastTeamEnd.next = end`，即让 1 指向 4。现在变成 `2 -> 1 -> 4 -> 3 -> 5`。
   - 更新 `lastTeamEnd` = 3。
3. **第三组 (5)**：
   - 凑不够 2 个，`teamEnd` 返回 null。
   - 直接结束，返回结果。

------

### 4. 【代码逐行精读】

**Part 1: 探路函数 `teamEnd`**

```java
// 作用：从 s 开始往下数 k 个，返回第 k 个节点。
// 如果不够 k 个，返回 null（告诉主函数别翻了）。
public static ListNode teamEnd(ListNode s, int k) {
    while (--k != 0 && s != null) {
        s = s.next;
    }
    return s;
}
```

**Part 2: 定界翻转函数 `reverse`**

```java
// 作用：把 s 到 e 这一段翻转过来。
// 关键点：不仅翻转内部，还负责把 s（翻转后变尾巴）连上下一组的开头。
public static void reverse(ListNode s, ListNode e) {
    e = e.next; // 【重要】先把 e 往后移一位，作为循环终止条件，同时也是下一组的头
    ListNode pre = null, cur = s, next = null;
    
    // 标准的翻转逻辑，只是终止条件变成了 cur != e
    while (cur != e) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    // 【点睛之笔】翻转完后，s 变成了当前组的尾巴。
    // 让它指向下一组的开头 (e)，保证链表不断裂。
    s.next = e;
}
```

**Part 3: 主流程 `reverseKGroup`**

```java
public static ListNode reverseKGroup(ListNode head, int k) {
    ListNode start = head;
    ListNode end = teamEnd(start, k); // 先探路，看第一组够不够
    
    if (end == null) {
        return head; // 第一组都不够，直接原样返回
    }
    
    // --- 第一组特殊处理 ---
    head = end; // 第一组的结尾，就是整个链表的新头
    reverse(start, end); // 翻转第一组
    
    // lastTeamEnd 记录上一组的“尾巴”，用来连接下一组的“头”
    // 翻转后，start 也就是原来的 1，变成了第一组的尾巴
    ListNode lastTeamEnd = start;
    
    // --- 后续组循环处理 ---
    while (lastTeamEnd.next != null) {
        start = lastTeamEnd.next; // 下一组的开始
        end = teamEnd(start, k);  // 下一组的探路
        
        if (end == null) {
            return head; // 这一组不够 k 个，说明到最后了，收工
        }
        
        // 翻转当前组
        reverse(start, end);
        
        // 【核心连接】上一组的尾巴 -> 指向 -> 当前组的新头(end)
        lastTeamEnd.next = end;
        
        // 更新上一组的尾巴为当前组的尾巴(start)
        lastTeamEnd = start;
    }
    return head;
}
```

------

### 5. 【死记硬背点 / 易错点】

1. **第一组必须单写**：因为如果第一组需要翻转，`head` 引用必须改变。如果写在 `while` 循环里，`head` 的更新逻辑会很别扭。
2. **`reverse` 函数的边界**：注意代码里 `e = e.next`。如果不提前保存下一组的头，翻转时链表就断了，找不到回家的路。
3. **谁连谁？**：是 `lastTeamEnd` (上一组尾) 去连 `end` (当前组翻转后的新头)。

------

### 6. 【复习闪卡 (Flashcard)】

1. **Q: 这个算法中 `reverse(s, e)` 方法做完后，`s.next` 指向哪里？**
   - A: 指向下一组的开始节点（即原来的 `e.next`）。这是为了保证链表不断开。
2. **Q: 为什么第一组要单独写在 while 循环外面？**
   - A: 因为第一组决定了最终返回的 `head` 是谁。后续组的翻转只影响中间连接，不影响全局 `head`。
3. **Q: 如果链表长度是 5，k=3，结果是怎样的？**
   - A: 前 3 个翻转，后 2 个保持原样。因为 `teamEnd` 在找第二组时会返回 null。



# 3. 复制带随机指针的链表

测试链接 : https://leetcode.cn/problems/copy-list-with-random-pointer/

## 代码

```java
public class Code03_CopyListWithRandomPointer {
    public static class Node {
        public int val;
        public Node next;
        public Node random;

        public Node(int v) {
            val = v;
        }
    }


    public static Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }

        Node cur = head;
        Node next = null;
        while (cur != null) {
            next = cur.next;
            cur.next = new Node(cur.val);
            cur.next.next = next;
            cur = next;
        }

        cur = head;
        Node copy = null;
        while (cur != null) {
            copy = cur.next;
            next = cur.next.next;

            copy.random = cur.random != null ? cur.random.next : null;
            cur = next;
        }

        Node ans = head.next;
        cur = head;
        while (cur != null) {
            copy = cur.next;
            next = cur.next.next;

            cur.next = next;
            copy.next = next != null ? next.next : null;
            cur = next;
        }

        return ans;
    }
}
```



## 思路

这份代码解决了 LeetCode 138 题：**随机链表的复制** (Copy List with Random Pointer)。

这是一个非常经典的 **“空间复杂度 O(1)”** 解法。通常深拷贝需要一个 HashMap 来记录 `原始节点 -> 新节点` 的映射关系（空间 O(N)），但这个解法利用链表本身的结构省去了 Map。



#### 1. 【一句话核心】

**“原地混编法”**：把克隆节点直接插在原节点的后面，形成一个“夹心饼干”链表，利用这就近关系找到 random 指针，最后再把它们拆分成两个独立的链表。

#### 2. 【算法关键技巧】

- **利用 `next` 代替 Map**：通常我们需要 Map 才知道原节点 A 对应哪个新节点 A'。在这里，`A.next` 直接就是 A'。
- **三步走战略**：
  1. **复制 (Copy)**：把 `1 -> 2` 变成 `1 -> 1' -> 2 -> 2'`。
  2. **连线 (Link Random)**：利用位置关系，`1'` 的 random 就是 `1` 的 random 的下一个（即 `1.random.next`）。
  3. **拆分 (Split)**：把“夹心”链表像拉链一样拉开，恢复原链表，提取新链表。

#### 3. 【图解原理】

假设原链表是 `1 -> 2`，且 `1` 的 random 指向 `2`。

步骤 1：混编插入

原结构：Node(1) -> Node(2)

插入后：Node(1) -> Node(1') -> Node(2) -> Node(2')

步骤 2：定位 Random

我们要找 1' 的 random。

- 既然 `1` 的 random 是 `2`。
- 那么 `1'` 的 random 应该是 `2'`。
- 在混编链表中，`2` 的 `next` 刚好就是 `2'`。
- **结论**：`copy.random = cur.random.next`。

------

#### 4. 【代码逐行精读】

**Loop 1: 复制节点并插入**

```java
while (cur != null) {
    next = cur.next; // 记下后面原本的节点
    cur.next = new Node(cur.val); // 新建一个克隆节点，接在 cur 后面
    cur.next.next = next; // 克隆节点接回原链表的后续
    cur = next; // 推进指针
}
// 此时链表变成了：原1 -> 克隆1 -> 原2 -> 克隆2 ...
```

**Loop 2: 设置 Random 指针 (核心逻辑)**

```java
cur = head;
while (cur != null) {
    next = cur.next.next; // next 指向下一个“原节点”（跳过克隆节点）
    copy = cur.next;      // copy 是当前的克隆节点
    
    // 【核心】如果原节点有 random，那么克隆节点的 random 就是原节点 random 的“下一个”
    // 因为所有克隆节点都在原节点后面，所以 cur.random.next 必定是 cur.random 的克隆体
    copy.random = cur.random != null ? cur.random.next : null;
    
    cur = next; // 推进到下一个原节点
}
```

**Loop 3: 拆分链表 (Unzip)**

```java
Node ans = head.next; // 结果链表的头，肯定是 head.next
cur = head;
while (cur != null) {
    next = cur.next.next; // next 指向下一个“原节点”
    copy = cur.next;      // copy 是当前的克隆节点
    
    cur.next = next;      // 【恢复原链表】：让原节点越过克隆节点，直连下一个原节点
    copy.next = next != null ? next.next : null; // 【连接新链表】：让克隆节点直连下一个克隆节点
    
    cur = next; // 推进
}
```

------

#### 5. 【死记硬背点 / 易错点】

1. **Map 方法 vs 混编方法**：面试如果没要求空间复杂度，用 HashMap 写最快最稳；要求 O(1) 空间必须背这个混编法。
2. **拆分时的空指针**：在 Loop 3 拆分时，`copy.next` 赋值要非常小心，必须判断 `next` (下一个原节点) 是否为 null。如果是 null，说明后面没节点了，`copy.next` 也该是 null。
3. **原链表要复原**：有时候题目要求不能破坏原链表结构，所以 Loop 3 不仅要提取 `ans`，还要把 `cur.next` 指回原来的样子。

------

#### 6. 【复习闪卡 (Flashcard)】

1. **Q: 为什么这个算法不需要 HashMap 就能找到克隆节点？**
   - A: 因为克隆节点就放在原节点的 `next` 位置，通过 `cur.next` 就能 O(1) 找到。
2. **Q: 核心公式：如何设置克隆节点的 random 指针？**
   - A: `copy.random = cur.random.next` (注意判空)。
3. **Q: 整个过程分哪三个循环？**
   - A: 1. 复制插入；2. 设置 Random；3. 拆分链表。



# 4. 判断链表是否是回文结构

测试链接 : https://leetcode.cn/problems/palindrome-linked-list/

## 代码

```java
/**
 * @Title: Code04_PalindromeLinkedList
 * @Author Wood
 * @Package PACKAGE_NAME
 * @Date 2026/1/2 19:52
 * @description: 判断链表是否是回文结构
 */
public class Code04_PalindromeLinkedList {
    public static class ListNode {
        public int val;
        public ListNode next;
    }

    public static boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) {
            return true;
        }

        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        ListNode pre = slow;
        ListNode cur = pre.next;
        ListNode next = null;
        pre.next = null;

        while (cur != null) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }

        boolean ans = true;
        ListNode left = head;
        ListNode right = pre;

        while (left != null && right != null) {
            if (left.val != right.val) {
                ans = false;
                break;
            }
            left = left.next;
            right = right.next;
        }

        cur = pre.next;
        pre.next = null;
        next = null;
        while (cur != null) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }

        return ans;
    }
}
```



## 思路

这是链表面试题中“**既要时间 O(N) 又要空间 O(1)**”的经典代表作。如果不限制空间，用栈或者数组非常简单；但在限制空间的情况下，必须动原链表的结构。

#### 1. 【一句话核心】

**“折叠对比法”**：用快慢指针找到中点，把后半段链表**逆序**（反转），然后左右两头往中间走，逐个对比数值。比完后，记得把后半段**还原**回去。

#### 2. 【算法关键技巧】

- **不仅要解题，还要“有素质”**：很多题解反转完判断出结果就直接返回了，留下一堆烂摊子（破坏了原链表结构）。左神强调**“怎么改的就怎么改回去”**，这是工程思维的体现。
- **中间点的细腻定位**：快慢指针的停止位置很有讲究。
  - 如果链表是奇数个 (`1->2->3->2->1`)，`slow` 会停在正中间 (`3`)。
  - 如果链表是偶数个 (`1->2->2->1`)，`slow` 会停在左边的中点 (`2`)。
  - 这保证了不管奇偶，反转后半部分的操作逻辑是一致的。

#### 3. 【图解原理】

假设链表：`1 -> 2 -> 3 -> 2 -> 1`

阶段一：找中点

快指针 (fast) 一次两步，慢指针 (slow) 一次一步。

结束后，slow 指向 3。

阶段二：后半段反转

我们从 slow 的下一个开始反转。

- 原始状态：`1 -> 2 -> 3 -> 2 -> 1 -> null`
- **反转后状态**：`1 -> 2 -> 3 <- 2 <- 1`
  - 注意：中间的 `3` 的 next 变成了 `null`。
  - 左指针 `left` 指向头 `1`。
  - 右指针 `right` 指向尾 `1`。

**阶段三：双向奔赴对比**

- `left` (1) 和 `right` (1) 对比 -> 相等 -> `left` 走一步，`right` 走一步。
- `left` (2) 和 `right` (2) 对比 -> 相等 -> 继续。
- 直到有一个为 `null` (撞到中间了)，结束。

阶段四：还原

把右边那半段再反转一次，恢复成 1 -> 2 -> 3 -> 2 -> 1。

------

#### 4. 【代码逐行精读】

**Part 1: 快慢指针找中点**

```java
// 标准的快慢指针写法
// 循环条件保证了 fast 能走到结尾或者倒数第二个
while (fast.next != null && fast.next.next != null) {
    slow = slow.next;      // 慢走1步
    fast = fast.next.next; // 快走2步
}
// 此时 slow 就在中点（奇数）或上中点（偶数）
```

**Part 2: 右半部分逆序**

```java
ListNode pre = slow;       // pre 先定在中点
ListNode cur = pre.next;   // cur 指向右半部分的第一个
ListNode next = null;
pre.next = null;           // 【关键】切断中点和右半部分的连接，让中点变成左半部分的尾巴(null)

// 标准的链表反转代码
while (cur != null) {
    next = cur.next;
    cur.next = pre;        // 指针反向指
    pre = cur;
    cur = next;
}
// 循环结束时，pre 指向整个链表原本的“尾巴”，也就是右半部分的“新头”
```

**Part 3: 两端向中间比对**

```java
ListNode left = head; // 左边从头开始
ListNode right = pre; // 右边从尾（也就是反转后的头）开始
boolean ans = true;

while (left != null && right != null) {
    if (left.val != right.val) {
        ans = false; // 发现不对称，标记为 false
        break;       // 【注意】这里不能直接 return，因为还要去执行还原操作
    }
    left = left.next;
    right = right.next;
}
```

**Part 4: 还原链表 (素质操作)**

```java
// 逻辑和反转时一模一样，就是把刚才反转的那段再转回来
cur = pre.next; // 这里的 pre 是最右边的尾巴
pre.next = null;
next = null;
while (cur != null) {
    next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
}
return ans;
```

------

#### 5. 【死记硬背点 / 易错点】

1. **快慢指针的边界**：`while (fast.next != null && fast.next.next != null)` 这个条件要背下来。这是针对“找上中点”最稳的写法。
2. **`break` 还是 `return`**：在比对过程中发现不是回文，千万别急着 `return false`，一定要 `break` 出去，让后面的还原代码跑完。这是面试加分项。
3. **中间节点的 `null`**：反转前，一定要把中间节点 (`slow`) 的 `next` 置为 `null`，否则链表会成环，导致死循环。

------

#### 6. 【复习闪卡 (Flashcard)】

1. **Q: 空间 O(1) 判断回文链表的四个步骤是什么？**
   - A: 1.快慢指针找中点；2.后半段反转；3.两头对比；4.后半段还原。
2. **Q: 反转后半段时，哪个节点充当了“中间墙壁”（null）的角色？**
   - A: 中点节点 (`slow`)。它的 `next` 被置为 `null`，标志着左半边的结束。
3. **Q: 为什么比对失败时不能直接 `return false`？**
   - A: 因为改变了输入的结构，必须执行后续的还原代码，恢复原样后再返回。



# 5. 返回链表的第一个入环节点

 测试链接 : https://leetcode.cn/problems/linked-list-cycle-ii/



## 代码

```java
public class Code05_LinkedListCycleII {
    public static class ListNode {
        public int val;
        public ListNode next;
    }

    public static ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) {
            return null;
        }

        ListNode slow = head.next;
        ListNode fast = head.next.next;

        while (slow != fast) {
            if (fast.next == null || fast.next.next == null) {
                return null;
            }

            slow = slow.next;
            fast = fast.next.next;
        }

        fast = head;
        while (slow != fast) {
            slow = slow.next;
            fast = fast.next;
        }

        return slow;
    }
}
```



## 思路

这是一个非常有名的算法，叫 **Floyd 判圈算法**（龟兔赛跑算法）。它的难点不在于代码长短，而在于**数学证明**（为什么要把它放回起点？）。

#### 1. 【一句话核心】

**“龟兔赛跑，相遇回零”**：先用快慢指针跑，若相遇则有环；相遇后，快指针**回到起点**变成慢指针，和原来的慢指针一起走，再次相遇的地方就是入环节点。

#### 2. 【算法关键技巧】

- **起跑姿势不同**：通常写法是 `slow=head, fast=head`。但左神的代码里，起手式是 `slow=head.next`，`fast=head.next.next`。
  - **原因**：如果一开始都指向 `head`，`while(slow != fast)` 条件一开始就不成立，循环进不去。为了省去 `do-while` 的写法，直接让它们先迈出第一步。
- **数学结论（背下来）**：假设起点到入环点距离为 $a$，相遇点到入环点距离为 $c$。数学推导证明了 **$a = c$**。这意味着：从**起点**出发走 $a$ 步，和从**相遇点**出发走 $c$ 步，会同时到达入环点。

#### 3. 【图解原理】

1. **第一阶段（判断有无环）**：
   - 快指针 (Fast) 一次走 2 步，慢指针 (Slow) 一次走 1 步。
   - 如果是直路，Fast 会直接冲到 null，返回 null。
   - 如果是环路，Fast 会在环里追上 Slow（套圈）。
2. **第二阶段（找入环点）**：
   - **此时关键操作**：让 Fast 指针瞬移回 Head（起点），且**速度降为 1**。
   - Slow 指针在相遇点保持不动，速度保持 1。
   - **齐步走**：两人同时迈步，一定会在**入环节点**相遇。

#### 4. 【代码逐行精读】

**Part 1: 边界检查与起跑**

Java

```
// 如果链表短于 3 个节点且没环，或者直接为空，那肯定没戏
if (head == null || head.next == null || head.next.next == null) {
    return null;
}
// 【注意】这里直接先走了第 1 步，避免 while 循环一开始就进不去
ListNode slow = head.next;
ListNode fast = head.next.next;
```

**Part 2: 第一次相遇（检测环）**

Java

```
while (slow != fast) {
    // 只要 fast 能走到 null，说明是直线，没环
    if (fast.next == null || fast.next.next == null) {
        return null;
    }
    slow = slow.next;
    fast = fast.next.next;
}
// 循环结束说明 slow == fast，相遇了！有环！
```

**Part 3: 第二次相遇（找入口）**

Java

```
fast = head; // 【核心】快指针回到起点
// 注意：现在的逻辑是两个指针都一次走一步
while (slow != fast) {
    slow = slow.next;
    fast = fast.next; // fast 变慢了，一次一步
}
// 再次相遇点，必是入环点
return slow;
```

#### 5. 【死记硬背点 / 易错点】

1. **Fast 回头变慢**：相遇后，`fast` 不仅要回到 `head`，而且步长要从 2 变成 **1**。
2. **起跑的坑**：如果你习惯写 `slow=head, fast=head`，记得用 `do-while` 或者在循环里加 `if` 判断跳出，否则循环条件一开始就失效。
3. **为什么一定能相遇？**：因为快指针比慢指针每次多走1步。在环里，这就相当于快指针在以 1 格的速度“逼近”慢指针，所以绝对不会“跳过”慢指针，一定会撞上。

#### 6. 【复习闪卡 (Flashcard)】

1. **Q: 怎么找到环形链表的入环点？（口诀）**
   - A: 快慢针，若相遇，快回头，步调齐，再相遇，即入口。
2. **Q: 为什么相遇后，一个从头走，一个从相遇点走，会在入口相遇？**
   - A: 数学性质决定。起点到入口的距离 = 相遇点到入口的距离（隐含了转了 N 圈的情况）。
3. **Q: 如果快指针一次走 3 步，还能一定在环里相遇吗？**
   - A: 不一定。步长差是 2，可能会跳过慢指针（如果环的长度适巧的话），导致永远追不上或者很久才追上。步长 1 和 2 是最优解。



# 6. 排序链表

要求时间复杂度O(n*logn)，额外空间复杂度O(1)，还要求稳定性

测试链接 : https://leetcode.cn/problems/sort-list/



## 代码

```java
public class Code06_SortList {
    public static class ListNode {
        public int val;
        public ListNode next;
    }

    public static ListNode sortList(ListNode head) {
        int n = 0;
        ListNode cur = head;
        while (cur != null) {
            n++;
            cur = cur.next;
        }

        ListNode l1, r1, l2, r2, next, lastTeamEnd;
        for (int step = 1; step < n; step <<= 1) {
            l1 = head;
            r1 = findEnd(head, step);
            l2 = r1.next;
            r2 = findEnd(l2, step);
            next = r2.next;

            r1.next = null;
            r2.next = null;

            merge(l1,r1,l2,r2);

            head = start;
            lastTeamEnd = end;

            while (next != null) {
                l1 = next;
                r1 = findEnd(l1, step);
                l2 = r1.next;
                if (l2 == null) {
                    lastTeamEnd.next = l1;
                    break;
                }
                r2 = findEnd(l2, step);
                next = r2.next;

                r1.next = null;
                r2.next = null;

                merge(l1,r1,l2,r2);
                lastTeamEnd.next = start;
                lastTeamEnd = end;
            }
        }

        return head;
    }
    public static ListNode start;

    public static ListNode end;

    private static void merge(ListNode l1, ListNode r1, ListNode l2, ListNode r2) {
        ListNode pre = null;
        if (l1.val <= l2.val) {
            start = l1;
            pre = l1;
            l1 = l1.next;
        }else {
            start = l2;
            pre = l2;
            l2 = l2.next;
        }

        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                pre.next = l1;
                l1 = l1.next;
            }else {
                pre.next = l2;
                l2 = l2.next;
            }
            pre = pre.next;
        }

        if (l1 != null) {
            pre.next = l1;
            end = r1;
        } else {
            pre.next = l2;
            end = r2;
        }
    }

    private static ListNode findEnd(ListNode s, int k) {
        while (s.next != null && --k != 0) {
            s = s.next;
        }
        return s;
    }


}
```



## 思路

在数组中，归并排序通常用递归（自顶向下），但递归会占用 O(log N) 的栈空间。为了达到题目要求的 **O(1) 额外空间**，我们必须使用非递归的方式：

- 先 2 个 2 个一组归并；
- 再 4 个 4 个一组归并；
- 再 8 个 8 个一组归并……直到结束。

由于链表不能像数组那样通过下标直接访问，我们需要维护大量的指针来标记“当前处理的这一段”在哪里。



#### 1. 【一句话核心】

**“步长倍增法”**：不使用递归，而是从步长 `step = 1` 开始，两两合并相邻的子链表，然后 `step` 翻倍（2, 4, 8...），直到步长超过链表长度。

#### 2. 【变量深度解析（图解字典）】

你提到的那几个变量是控制“局部归并”的核心。想象我们正在处理链表中间的某一段，要把**左半部分（有序）**和**右半部分（有序）**合并。

假设 `step = 2`，我们要合并两个长度为 2 的段：

```
...[已处理好的前驱] -> [ 4 -> 7 ] -> [ 1 -> 5 ] -> [ 9 -> ... ]
```

- **`l1` (Left 1)**: **左组的头**。也就是 `4`。
- **`r1` (Right 1)**: **左组的尾**。也就是 `7`。
  - *作用*：界定第一组的范围是 `l1` 到 `r1`。
- **`l2` (Left 2)**: **右组的头**。也就是 `1`。
- **`r2` (Right 2)**: **右组的尾**。也就是 `5`。
  - *作用*：界定第二组的范围是 `l2` 到 `r2`。
- **`next`**: **下一组的头**。也就是 `9`。
  - *作用*：因为合并操作会打乱 `r2` 的 `next` 指针，我们必须先由 `next` 记下后面还没处理的节点，否则链表就断了。
- **`lastTeamEnd`**: **上一组合并完后的尾巴**。也就是 `[已处理好的前驱]` 的最后一个节点。
  - *作用*：**这是连接的关键！** 当我们把 `l1..r1` 和 `l2..r2` 合并成一个新的有序串后，我们需要让 `lastTeamEnd.next` 指向这个新串的头，把断开的链表重新连起来。

#### 3. 【代码逻辑精读】

**Part 1: 步长循环 (Outer Loop)**

```java
// step 从 1 开始，每次翻倍：1 -> 2 -> 4 -> 8
for (int step = 1; step < n; step <<= 1) {
    // 每次步长变了，都需要从头开始遍历链表
    // 下面分别处理“第一组”和“后续组”
}
```

Part 2: 第一组特殊处理

为什么第一组特殊？ 因为第一组归并完，整个链表的 head 可能会变（比如 l2 比 l1 小，头就变成了 l2）。而且第一组没有 lastTeamEnd。

```java
l1 = head;
r1 = findEnd(l1, step); // 往下数 step 步，找到左组尾巴
l2 = r1.next;           // 右组头紧跟在左组尾后面
r2 = findEnd(l2, step); // 往下数 step 步，找到右组尾巴
next = r2.next;         // 【关键】记下后面还没处理的开头

// 【断链操作】为了让 merge 函数把它们当成独立的链表处理，
// 必须把尾巴断开，否则 merge 会一直跑到链表尽头。
r1.next = null;
r2.next = null;

merge(l1, r1, l2, r2);  // 合并！merge函数会更新全局变量 start 和 end
head = start;           // 更新整个链表的头（如果是第一次归并，这里确定了新的 head）
lastTeamEnd = end;      // 记录当前组的尾巴，给下一组用
```

**Part 3: 后续组循环 (Inner Loop)**

```java
while (next != null) {
    l1 = next;            // 上一组的 next 就是这一组的 l1
    r1 = findEnd(l1, step);
    l2 = r1.next;
    
    // 边界处理：如果凑不齐一对（比如只有左组，没有右组）
    if (l2 == null) {
        lastTeamEnd.next = l1; // 直接把剩下的连上，收工
        break;
    }
    
    r2 = findEnd(l2, step);
    next = r2.next;       // 再次记下后面
    
    r1.next = null;       // 再次断链
    r2.next = null;
    
    merge(l1, r1, l2, r2);
    
    // 【连接操作】把上一组的尾巴，连上当前组归并后的头
    lastTeamEnd.next = start;
    lastTeamEnd = end;    // 更新尾巴，为下下一组做准备
}
```

**Part 4: Merge 函数 (利用全局变量)**

```java
// 为了方便，这里用了 static 变量 start 和 end 来“返回”合并后的头和尾。
// 这里的逻辑就是标准的“合并两个有序链表”，只是多了维护 end 指针。
public static void merge(ListNode l1, ListNode r1, ListNode l2, ListNode r2) {
    // ... 标准比较合并逻辑 ...
    
    // 最后一定要维护 end 指针，指向合并后链表的最后一个节点
    // 因为外部循环需要用这个 end 赋值给 lastTeamEnd
    if (l1 != null) {
        pre.next = l1;
        end = r1; // 如果 l1 剩下了，尾巴就是 r1
    } else {
        pre.next = l2;
        end = r2; // 如果 l2 剩下了，尾巴就是 r2
    }
}
```

#### 4. 【死记硬背点 / 易错点】

1. **断链 (`.next = null`)**：在调用 `merge` 之前，必须把 `r1.next` 和 `r2.next` 置为空。否则 `merge` 函数不知道链表在哪里结束，会把后面不需要合并的节点也卷进来，导致死循环或混乱。
2. **`lastTeamEnd` 的连接**：千万别忘了 `lastTeamEnd.next = start`。这是把“碎片”重新串成一条长链表的关键动作。
3. **步长翻倍**：`step <<= 1`。
4. **`findEnd` 的判空**：在找 `r1` 或 `r2` 时，如果链表剩余长度不够 `step`，要直接返回最后一个节点，不能报错。

#### 5. 【复习闪卡 (Flashcard)】

1. **Q: 为什么不能直接用递归的归并排序？**
   - A: 题目要求空间复杂度 O(1)。递归会使用 O(log N) 的栈空间。
2. **Q: 变量 `next` 的作用是什么？**
   - A: 它是“下一轮比赛的选手”。因为当前轮次归并时会打断指针连接，必须先保存下一组的开头位置。
3. **Q: 在 `merge` 之前，为什么要执行 `r1.next = null`？**
   - A: 为了隔离。把长链表切断成两个独立的短链表传给 merge 函数，防止 merge 越界。





























