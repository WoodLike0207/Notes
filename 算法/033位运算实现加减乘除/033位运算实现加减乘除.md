![image-20251229211857638](033%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4.assets/image-20251229211857638.png)



# 1. 位运算实现加法和减法



## 代码

```java
public static int add(int a,int b) {
    int ans = a;
    while (b != 0) {
        ans = a ^ b;
        b = (a & b) << 1;
        a = ans;
    }

    return ans;
}

public static int neg(int n){
    return add(~n,1);
}

public static int minus(int a, int b) {
    return add(a, neg(b));
}
```



## 原理

### 1. `add` 方法原理：拆分“本位”与“进位”

在小学学加法时（比如 `18 + 5`），老师教我们：

1. **个位相加**：$8 + 5 = 3$（本位结果），进 $1$。
2. **处理进位**：十位的 $1$ 加上进位的 $1$，等于 $2$。
3. **结果**：$23$。

位运算加法的思想完全一样，只是它是二进制的：

我们将加法分为两个独立的部分循环执行，直到没有进位为止。

#### 核心公式

1. **无进位加法（Sum without Carry）**：对应 **异或 (`^`)**
   - $1+0=1, 0+1=1, 0+0=0, 1+1=0$
   - 你看，这跟异或运算 `a ^ b` 是一模一样的（相同为0，不同为1）。
2. **进位信息（Carry）**：对应 **与运算 (`&`) + 左移 (`<< 1`)**
   - 只有 $1+1$ 才会产生进位。
   - `a & b` 可以找出哪些位是“都有1”的。
   - `<< 1` 是因为进位是要加到**下一位**去的。

------

### 2. 代码逐行解析与 Trace（追踪）

让我们用一个简单的例子来“跑”一遍代码：计算 **$5 + 7 = 12$**。

- `a = 5` (二进制 `0101`)
- `b = 7` (二进制 `0111`)

#### 第一轮循环

- 计算本位和 (ans)：a ^ b

  0101 ^ 0111 = 0010 (十进制 2)

  (注意：这里没管进位，直接把1+1变成了0)

- **计算进位 (`b`)**：`(a & b) << 1`

  1. `0101 & 0111 = 0101` (发现第0位和第2位都需要进位)
  2. `0101 << 1 = 1010` (进位挪到了第1位和第3位)

- 更新：

  a = 0010 (当前的本位和)

  b = 1010 (当前的进位值，十进制 10)

  此时 b 不为 0，继续循环。这意味着我们还没加完，要把进位加到刚才的结果里。

#### 第二轮循环

- 计算本位和 (ans)：a ^ b

  0010 ^ 1010 = 1000 (十进制 8)

- **计算进位 (`b`)**：`(a & b) << 1`

  1. `0010 & 1010 = 0010` (发现第1位又撞车了，1+1)
  2. `0010 << 1 = 0100` (进位挪到第2位)

- 更新：

  a = 1000

  b = 0100

#### 第三轮循环

- 计算本位和 (ans)：a ^ b

  1000 ^ 0100 = 1100 (十进制 12，结果出来了！)

- **计算进位 (`b`)**：`(a & b) << 1`

  1. `1000 & 0100 = 0000` (没有位重叠了，没有进位)
  2. `0 << 1 = 0`

- 更新：

  a = 1100

  b = 0

  此时 b 为 0，循环结束。

#### 返回结果

- `return ans`，即 `1100` (十进制 12)。正确！

------

### 3.  `neg` (取相反数) 原理

Java

```
public static int neg(int n) {
    return add(~n, 1);
}
```

这是基于计算机的 **补码（Two's Complement）** 定义。

在计算机中，$-n$ 的二进制表示法就是：**将 $n$ 的各个位取反（`~n`），然后加 1。**

- 例如 `n = 1` (`0001`)
- `~n` = `1110`
- `add(~n, 1)` = `1111`
- 在 int 中，全 1 (`111...1`) 代表的就是 `-1`。

这里调用 `add` 而不是直接写 `+ 1`，是为了保证整个过程纯粹只用位运算，不依赖系统的加法操作符。

------

### 4.  `minus` (减法) 原理

```java
public static int minus(int a, int b) {
    return add(a, neg(b));
}
```

这个非常简单，数学原理：

$$a - b = a + (-b)$$

既然我们已经有了“加法器 (`add`)”和“求相反数 (`neg`)”，减法自然就是把 $b$ 变成负数，然后加上 $a$。

### 5. 总结

- **加法**：利用 `^` 模拟加法（不带进位），利用 `& << 1` 模拟进位，循环直到进位消失。
- **取反**：利用补码性质 `~n + 1`。
- **减法**：转化为加法 `a + (-b)`。

这套逻辑不仅适用于 Java，在 C/C++ 等所有底层开发中都是通用的，也是 CPU 内部电路工作的基本原理。



# 2. 位运算实现乘法

## 代码

```java
public static int multiply(int a, int b) {
    int ans = 0;

    while (b != 0) {
        if ((b & 1) != 0) {
            ans = add(ans, a);
        }

        a <<= 1;
        b >>>= 1;
    }

    return ans;
}
```



## 原理

位运算实现乘法的核心原理其实就是我们在小学数学课上学的 **“竖式乘法”**（Long Multiplication），只不过这里是二进制版本。

### 1.  核心原理：二进制竖式乘法

想象一下我们怎么算十进制的 $12 \times 11$：

```
    1 2
  x 1 1
  -----
    1 2   <-- 12 * 1 (个位)
  1 2 0   <-- 12 * 10 (十位，左移一位)
  -----
  1 3 2
```

二进制也是一模一样的逻辑。

假设我们要算 $a \times b$。我们遍历 $b$ 的每一位：

- 如果 $b$ 的当前位是 **1**：就把 $a$ 加上去。
- 如果 $b$ 的当前位是 **0**：就不加（相当于加0）。
- 每处理完 $b$ 的一位，$a$ 就要**左移一位**（`<< 1`，相当于 $\times 2$），准备处理下一位权重更高的数。

------

### 2. 代码逐行解析

```java
public static int multiply(int a, int b) {
    int ans = 0; // 累加器，存放最终结果
    
    // 只要乘数 b 还没变成 0，就继续循环
    while (b != 0) {
        
        // 【判断】考察 b 二进制的最右边一位（最低位）是不是 1
        if ((b & 1) != 0) {
            // 如果是 1，说明这一位需要把当前的 a 加到结果里
            ans = add(ans, a);
        }
        
        // 【移位 a】：被乘数左移一位
        // 随着 b 的处理位置往高位走，a 代表的值也要翻倍
        // 比如处理 b 的第0位时 a是a；处理 b 的第1位时，a其实代表 a*2
        a <<= 1; 
        
        // 【移位 b】：乘数无符号右移一位
        // 把刚刚处理过的最低位扔掉，让下一位来到最低位
        b >>>= 1;
    }
    return ans;
}
```

### 3. 用例图解演示

让我们来算一个简单的：$a = 5$ (0101) 乘以 $b = 3$ (0011)。

预期结果是 15。

#### 初始状态

- `ans = 0`
- `a = 0000 0101` (5)
- `b = 0000 0011` (3)

#### 第一轮循环

1. **检查 b 的最低位**：`b & 1`。`0011` 的最后一位是 **1**。
2. **累加**：`ans = add(0, 5)` -> `ans = 5`。
3. **移位**：
   - `a` 左移变大：`0000 1010` (10)
   - `b` 右移变小：`0000 0001` (1)

#### 第二轮循环

1. **检查 b 的最低位**：`0001` 的最后一位是 **1**。
2. **累加**：`ans = add(5, 10)` -> `ans = 15`。
3. **移位**：
   - `a` 左移变大：`0001 0100` (20)
   - `b` 右移变小：`0000 0000` (0)

#### 第三轮循环

- `while (b != 0)` 检查发现 `b` 已经是 0 了。
- **循环结束**。

#### 返回结果

- `return 15`。结果正确！

------

### 4. 关键点：为什么用 `>>>` 而不是 `>>`？

注意看代码中 `b >>>= 1` 使用的是 **无符号右移**。这是一个非常重要的细节！

- 如果用 >> (带符号右移)：

  如果 b 是一个负数（比如 -1，二进制全是 1：111...111），带符号右移补位时会一直补 1。

  这意味着 b 永远不会变成 0，程序会陷入死循环。

- 如果用 >>> (无符号右移)：

  不管 b 是正数还是负数，高位都补 0。这样经过 32 次循环后，b 一定会变成 0，保证循环能正常结束。

### 5. 总结

计算机底层的乘法器（Multiplier）实际上就是由**移位器**和**加法器**组成的。

- **`a <<= 1`**：模拟竖式乘法中每换一行，数字就要往左错一位。
- **`if ((b & 1) != 0)`**：模拟竖式乘法中，只有乘数的某一位是 1，才把上面的数抄下来；如果是 0 就不抄。



# 3. 位运算实现除法

## 代码

```java
public static int div(int a, int b) {
    int x = a < 0 ? neg(a) : a;
    int y = b < 0 ? neg(b) : b;
    int ans = 0;

    for (int i = 30; i >= 0; i = minus(i, 1)) {
        if ( (x >> i) >= y) {
            ans |= (1 << i);
            x = minus(x, y << i);
        }
    }

    return a < 0 ^ b < 0 ? neg(ans) : ans;
}
```





## 原理

位运算实现除法是四则运算中**最难**的一个，被称为“算术运算的BOSS关卡”。

它的核心思想和乘法完全相反。乘法是“累加移位”，而除法是 **“贪心减法”**（或者叫 **二进制竖式除法**）。

------

### 1. 核心原理：逆向逼近

想象你要计算 $X \div Y$。

这就好比你要用 $Y$ 去填满 $X$。因为是二进制，我们尝试用 $Y \times 2^{30}, Y \times 2^{29}, \dots, Y \times 2^1, Y \times 2^0$ 这些“大块”去试探。

公式逻辑是寻找一个系数 $Q$（商），使得：



$$X = Y \times Q + R \quad (R < Y)$$

我们把 $Q$ 拆成二进制形式：



$$X = Y \times (2^{i_1} + 2^{i_2} + \dots) + R$$

**步骤：**

1. 我们从最大的倍数开始试（比如 $2^{30}$）。
2. 够不够减？
   - 如果 $X$ 够减 $Y \times 2^{30}$，说明商的第 30 位是 1。把这一大块减掉，剩下的继续算。
   - 如果不够减，说明商的第 30 位是 0。
3. 把倍数缩小一半（$2^{29}$），重复上述过程。

------

### 2. 代码深度解析

这段代码利用了之前的 `neg` (取反) 和 `minus` (减法) 函数。

Java

```
public static int div(int a, int b) {
    // 1. 转为绝对值计算
    // 负数处理很麻烦，先全部变成正数算，最后再定符号。
    // 注意：这里有一个隐患，如果 a 是 Integer.MIN_VALUE，取反会溢出，
    // 标准的完整除法代码需要专门处理 MIN_VALUE，但为了讲解原理，我们暂且认为输入不越界。
    int x = a < 0 ? neg(a) : a;
    int y = b < 0 ? neg(b) : b;
    
    int ans = 0; // 存放商
    
    // 2. 从第 30 位开始循环尝试
    // 为什么是 30？因为 int 是 32 位，符号位占 1 位（第31位），
    // 剩下的数值位最高是第 30 位。
    for (int i = 30; i >= 0; i = minus(i, 1)) {
        
        // 3. 核心判断：x 够不够减 (y * 2^i) ?
        // 这里的写法非常讲究： (x >> i) >= y
        // 等价于： x >= (y << i)
        // 为什么不写成下面那样？因为 y << i 可能会溢出变成负数！
        // 用 x 右移来比较是非常安全的做法。
        if ((x >> i) >= y) {
            
            // 够减！说明商的第 i 位是 1
            ans |= (1 << i);
            
            // 更新 x：减去这一大块 (y * 2^i)
            // 这里用了你之前定义的减法 minus
            x = minus(x, y << i);
        }
    }
    
    // 4. 恢复符号
    // a和b符号不同(true) -> 结果为负；符号相同(false) -> 结果为正
    // 异或 (^) 刚好能处理这个逻辑。
    return a < 0 ^ b < 0 ? neg(ans) : ans;
}
```

------

### 3. 用例图解演示

让我们计算 **$22 \div 3$**。

- `a = 22` (二进制 `10110`)
- `b = 3` (二进制 `00011`)
- `x = 22`, `y = 3`, `ans = 0`

程序开始循环 `i` 从 30 到 0。前面的循环（30...3）因为 `x` 太小，`x >> i` 都是 0，肯定小于 3，直接跳过。

**当循环来到 `i = 2` 时：**

1. **检查**：`x >> 2` 即 `22 >> 2` (二进制 `101`，即 5)。
   - $5 \ge 3$ (即 `y`) 成立！
   - 这意味着 $22$ 里面至少包含了 $3 \times 2^2 = 12$。
2. **记录商**：`ans |= (1 << 2)` -> `ans` 的第 2 位置 1。此时 `ans = 4` (100)。
3. **减去**：`x = x - (3 << 2)` -> `22 - 12 = 10`。
   - 现在剩下了 `x = 10`。

**当循环来到 `i = 1` 时：**

1. **检查**：`x >> 1` 即 `10 >> 1` (即 5)。
   - $5 \ge 3$ 成立！
   - 这意味着剩下的 $10$ 里面至少包含了 $3 \times 2^1 = 6$。
2. **记录商**：`ans |= (1 << 1)` -> `ans` 的第 1 位置 1。此时 `ans = 6` (110)。
3. **减去**：`x = x - (3 << 1)` -> `10 - 6 = 4`。
   - 现在剩下了 `x = 4`。

**当循环来到 `i = 0` 时：**

1. **检查**：`x >> 0` 即 `4`。
   - $4 \ge 3$ 成立！
   - 这意味着剩下的 $4$ 里面至少包含了 $3 \times 2^0 = 3$。
2. **记录商**：`ans |= (1 << 0)` -> `ans` 的第 0 位置 1。此时 `ans = 7` (111)。
3. **减去**：`x = x - (3 << 0)` -> `4 - 3 = 1`。
   - 现在剩下了 `x = 1`。

**循环结束**

- 返回 `ans = 7`。
- 如果是求余数，最后的 `x = 1` 就是余数。
- $22 \div 3 = 7 \dots 1$。正确！

------

### 4. 关键点：为什么是 `(x >> i) >= y`？

这是一个很多初学者容易写错的地方。

直觉上我们想写 if (x >= (y << i))。

但是，假设 $y$ 是一个比较大的数，比如 $100000$。

当 $i$ 很大时（比如 20），$y \ll 20$ 会直接溢出掉出 32 位整数范围，变成一个负数或者很小的错误的数。

这时候 x >= 错误数 就会导致逻辑判断出错。

**改为 `x >> i` 则是把大数缩小，绝对不会溢出，非常安全。**

### 5. 系统极值处理（Integer.MIN_VALUE）

如果这是一道 LeetCode 题目（LeetCode 29. 两数相除），上面的代码会遇到一个 BUG：

如果输入 a = -2147483648 (即 Integer.MIN_VALUE)。

第一行 x = neg(a) 会试图把它变成正数。

但在 32 位补码系统中，最小值的绝对值比最大值大 1，所以最小值取反还是它自己（或者溢出）。

**LeetCode 版本的通用解法**通常会把 `int` 强转成 `long` 来避免这个问题，或者对 MIN_VALUE 做特殊判断：

```java
// 如果不能用 long，就需要在一开始特判
if (a == Integer.MIN_VALUE && b == -1) return Integer.MAX_VALUE;
if (a == Integer.MIN_VALUE && b == 1) return Integer.MIN_VALUE;
// ... 以及其他边界处理
```



# 4. 实现除法时的一些边界处理

测试链接：https://leetcode.cn/problems/divide-two-integers/



## 代码

```java
/**
 * @Title: BitOperationAddMinusMultiplyDivide
 * @Author Wood
 * @Package PACKAGE_NAME
 * @Date 2026/1/1 15:35
 * @description:
 */
public class BitOperationAddMinusMultiplyDivide {
    public static int MIN = Integer.MIN_VALUE;

    public static int divide(int a, int b) {
        if (a == MIN && b == MIN) {
            return 1;
        }

        if (a != MIN && b != MIN) {
            return div(a, b);
        }

        if (b == MIN) {
            return 0;
        }

        if (b == neg(1)) {
            return Integer.MAX_VALUE;
        }

        // a是整数最小，b不是整数最小，b也不是-1
        a = add(a, b > 0 ? b : neg(b));
        int ans = div(a , b);
        int offset = b > 0 ? neg(1) : 1;
        return add(ans, offset);
    }


    public static int add(int a,int b) {
        int ans = a;
        while (b != 0) {
            ans = a ^ b;
            b = (a & b) << 1;
            a = ans;
        }

        return ans;
    }

    public static int neg(int n){
        return add(~n,1);
    }

    public static int minus(int a, int b) {
        return add(a, neg(b));
    }

    public static int multiply(int a, int b) {
        int ans = 0;

        while (b != 0) {
            if ((b & 1) != 0) {
                ans = add(ans, a);
            }

            a <<= 1;
            b >>>= 1;
        }

        return ans;
    }

    public static int div(int a, int b) {
        int x = a < 0 ? neg(a) : a;
        int y = b < 0 ? neg(b) : b;
        int ans = 0;

        for (int i = 30; i >= 0; i = minus(i, 1)) {
            if ( (x >> i) >= y) {
                ans |= (1 << i);
                x = minus(x, y << i);
            }
        }

        return a < 0 ^ b < 0 ? neg(ans) : ans;
    }

}
```



## 原理

这段代码是实现 32 位整数除法（LeetCode 29 题风格）的**入口函数**。

它存在的唯一原因就是为了解决 **`Integer.MIN_VALUE` (即 $-2^{31}$)** 的令人头秃的问题。

### 核心痛点：为什么 `MIN_VALUE` 这么特殊？

在计算机补码系统中：

- 最大值 `MAX` = $2^{31} - 1$ = `2147483647`
- 最小值 `MIN` = $-2^{31}$ = `-2147483648`

关键问题： MIN 的绝对值是 $2^{31}$，这比 MAX 还大 1。

如果你试图执行 Math.abs(MIN) 或者代码里的 neg(MIN)，结果依然是 MIN（因为正数范围装不下）。

之前我们写的 `div` 函数第一步就是把数字转成正数 (`x = a < 0 ? neg(a) : a`)。如果直接传 `MIN` 进去，这一步就会失效，导致死循环或逻辑错误。

因此，`divide` 函数充当了**“安检员”**，专门处理这些极端边界，保证传给 `div` 函数的数字永远不会是 `MIN`。

------

### 代码详细逻辑拆解

#### 1. 两个都是最小值

```java
if (a == MIN && b == MIN) {
    return 1;
}
```

- **逻辑**：任何数除以它自己都等于 1。
- **如果不处理**：`div` 函数试图转正两个 `MIN`，都会失败。

#### 2. 两个都不是最小值（快乐路径）

```java
if (a != MIN && b != MIN) {
    return div(a, b);
}
```

- **逻辑**：这是最常见的情况。既然没有 `MIN` 的干扰，绝对值都不会溢出，直接调用核心算法 `div` 即可。

#### 3. 除数是最小值

```java
if (b == MIN) {
    return 0;
}
```

- **逻辑**：
  - 程序走到这里，说明 **`a` 不是 MIN** (因为前面判断过了)，但 **`b` 是 MIN**。
  - 这意味着 `|b| > |a|`。
  - 除数比被除数绝对值大，整数除法结果一定是 **0**。

#### 4. 被除数是 MIN，除数是 -1

```java
if (b == neg(1)) {
    return Integer.MAX_VALUE;
}
```

- **逻辑**：
  - 计算 $-2^{31} \div -1$。
  - 数学结果应该是 $2^{31}$。
  - 但是 `int` 能存的最大数是 $2^{31} - 1$。结果溢出了！
- **题目要求**：这道题通常规定，如果溢出，返回 `Integer.MAX_VALUE`。如果不加这个判断，结果会变成 `MIN` (错误)。

#### 5. 被除数是 MIN，除数是普通数（最难理解的部分）

```java
// a是整数最小，b不是整数最小，b也不是-1
a = add(a, b > 0 ? b : neg(b));
int ans = div(a, b);
int offset = b > 0 ? neg(1) : 1;
return add(ans, offset);
```

这是**“补偿法”**。

既然 a 是 MIN，我们不能直接转正。那我们就让 a 稍微变大一点点，让它脱离 MIN 这个尴尬的位置，然后再算，最后把少算的那部分补回来。

原理推导：

我们要算 $a \div b$。

因为 $a$ 是最小值，我们把它加上一个 $|b|$，变成 $a'$。



$$a' = a + |b|$$



此时 $a'$ 绝对不再是 MIN 了（因为变大了），可以安全放入 div 计算。

根据除法分配律：



$$\frac{a}{b} = \frac{a + |b| - |b|}{b} = \frac{a + |b|}{b} - \frac{|b|}{b}$$

这里 $\frac{a + |b|}{b}$ 就是代码中的 div(a, b)（因为此时 a 已经被修改了）。

而 $\frac{|b|}{b}$ 的结果或者是 1，或者是 -1。

举例演示（缩小范围演示）：

假设系统 MIN 是 -8。我们要算 -8 / 2。正确结果是 -4。

1. 处理 a：

   a 是 -8，不能转正。

   我们先让 a 加一个 b： a = -8 + 2 = -6。

   （现在 a 是 -6，可以安全转正计算了）

2. 计算除法：

   ans = div(-6, 2)。结果是 -3。

3. 计算补偿 (offset)：

   因为我们在第一步让 a 往 0 的方向缩短了 1 个 b 的距离，所以商肯定少算了 1（或者是多加了 1，取决于符号）。

   这里 b = 2 (大于0)，说明我们把被除数变大了，结果（负数）绝对值变小了，相当于结果变大了。我们需要减去 1。

   代码逻辑：offset = b > 0 ? neg(1) : 1 -> offset = -1。

4. 最终结果：

   ans + offset = -3 + (-1) = -4。

   完美！

再举个负数除数的例子：

算 -8 / -2。正确结果是 4。

1. 处理 a：

   b 是 -2，neg(b) 是 2。

   a = -8 + 2 = -6。

2. 计算除法：

   ans = div(-6, -2)。结果是 3。

3. 计算补偿：

   b = -2 (不大于0)，代码逻辑 offset = 1。

4. 最终结果：

   3 + 1 = 4。

   完美！

### 总结

`divide` 函数的本质是一系列的**防御性编程**：

1. 先排除 `MIN/MIN`。
2. 处理常规情况。
3. 排除 `Anything/MIN`。
4. 排除 `MIN/-1` (溢出)。
5. 最后用**补偿法**处理 `MIN/常规数`，巧妙避开 `MIN` 无法取绝对值的问题。

















